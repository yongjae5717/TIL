# OS
## 1. OS란?
### 운영체제란?
- 운영체제는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모입이다.
- 운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공해 준다.
- <img src="./image/20220930_OS_Diagram.png">

### 운영체제의 5가지 구성요소
- <img src="./image/20220930_Components_of_OS.png">
- OS는 Kernel과 Utility-Program으로 나눈다.
#### Kernel
- 운영체제의 핵심
- 컴퓨터가 처음 부팅될 때, 주기억 장치에 적재되어 시스템 종료전까지 계속 주 기억장치에 적재되는 프로그램.
- 빈번하게 실행되는 프로그램을 디스크에 둘 경우 주 기억장치와 디스크간의 입출력이 너무 빈번하게 일어나기 때문에 성능 저하가 발생한다.
- 즉, 필수적으로 자주 쓰이는 프로그램을 메모리에 상주시키는 프로그램을 Kernel이라 한다.
- Kernel보다 더 빠른 실행이 필요하고 높은 수준의 보호가 필요한 것은 마이크로 프로그래밍을 진행하여 ROM or PLA같은 칩으로 만들기도 하는데 이를 펌웨어라고 한다.
- 펌웨어: 외적으로는 하드웨어, 내적으로는 프로그램

#### Utility-Program
- 어떤 문제를 해결하기 위해서 사용자 또는 특정 업무에 대한 전문가들에 의해서 작성된 프로그램이다.

### OS의 목적
- 사용자의 편리성과 자원을 효율적으로 사용하기 위함이다.

## 2. Context Switching
### Q. 컨택스트 스위칭에 대하여 설명하세요.
- 컨택스트 스위칭은 하나의 task가 끝날 때까지 기다리지 않고, 동시에 여러 task를 번갈아가면서 실행하는 방법이다.
- 인터럽트가 발생하면 현재 프로세스의 상태를 PCB에 저장하고 새로운 프로세스의 상태를 레지스터에 저장한다. 이와 같은 과정은 cpu는 아무 일도 하지 않기 때문에 잦은 컨택스트 스위칭은 성능저하를 야기한다.
- 스레드와 프로세스의 동작방식이 약간 상이한데, 스레드는 캐시 메모리나 PCB에 저장해야하는 내용이 적고, 비워야 하는 내용도 적기 때문에 상대적으로 더 빠른 컨택스트 스위칭이 일어날 수 있다.

### Context
- OS에서 컨택스트는 CPU가 프로세스를 실행하기 위해서 필요한 프로세스에 관한 정보이다.

### PCB (Process Control Block)
- 프로세스(Process)가 생성되면 메모리에 해당 프로세스의 PCB가 함께 생성되고, 종료시 삭제된다.
- PCB는 관리 대상 프로세스에 대한 정보를 포함하는 운영체제 Kernel 내부에 존재하는 자료구조이다.
- CPU는 프로세스를 실행할 때, PCB에 있는 해당 프로세스의 컨택스트를 읽어서 레지스터 값을 변경한다.

### 컨택스트 스위칭
- <img src="./image/20220930_Context_Switching.png">
- 멀티프로세스 환경에서 CPU가 어떤 하나의 프로세스를 실행하고 있는 상태에서 인터럽트 요청에 의해 다음 우선 순위의 프로세스가 실행되어야 할 때, 기존의 프로세스의 상태 또는 
레지스터 값을 저장하고, CPU가 다음 프로세스를 수행하도록 새로운 프로세스의 상태 또는 레지스터 값으로 교체하는 작업이다.
- CPU의 개수가 스레드의 개수보다 같거나 적으면 Context Switching이 발생하지 않는다.
- 프로세스 간의 Context Switching은 OS 스케쥴러가 담당한다.

### 인터럽트
- CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치에 예외상황이 발생하여 처리가 필요한 경우 CPU에게 알려 처리할 수 있도록 하는 것이다.
- 인터럽트가 발생하면 프로세스가 하던 일을 멈추고 이미 정해진 코드에서 요청에 대한 처리를 수행한다.
- 컨텍스트 스위칭이 발생시키는 인터럽트 종류
  - I/O request: 입출력 (I/O) 요청이 왔을 경우
  - Time Slice Expired: CPU 사용시간이 만료되었을 경우
  - Fork a Child: 자식 프로세스를 만들 경우
  - Wait for an Interrupt: 인터럽트 처리를 기다릴 경우

### 프로세스, 스레드 컨텍스트 스위칭
#### 프로세스 컨텍스트 스위칭
- 각 프로세스는 공유하는 데이터가 없기 때문에 Cache가 지금껏 쌓은 데이터를 없애고 새로운 Cache 정보를 쌓아야 한다는 부담요소가 있다.
#### 스레드 컨텍스트 스위칭
- 서로 공유하는 영역 (Code, Data, Heap)에 대한 Cache 정보를 사용할 수 있기 때문에 프로세스 컨텍스트 스위칭보다 부담이 적다.

### OS 스케쥴러
- 컨택스트 스위칭을 하는 주체이다.
- 인터럽트가 발생했을 때, 다음 차례로 수행할 프로세스를 결정한다.
- 프로세스를 Time-Slicing을 통해 동시에 수행하는 것처럼 보이게 하지만 사실은 하나씩 처리한다.

## 3. 동기와 비동기
### Q. 동기와 비동기의 차이?
- 동기: 메소드를 실행시킴과 동시에 반환 값이 기대되는 경우
- 비동기: 메소드를 실행시킴과 동시에 반환되지 않는 경우
- 동시라는 말은 실행되었을 때, 값이 반환되기 전까지는 Blocking 되었다는 것을 의미한다.
- 비동기의 경우, Blocking되지 않고 이벤트 큐에 넣거나 백그라운드 스레드에게 해당 task를 위임하고, 바로 다음 코드를 실행하기 때문에 기대되는 값이 바로 반환되지 않는다.

### 동기와 비동기
- 동기 방식은 메소드 리턴과 결과를 전달받는 시간이 일치하는 명령 실행 방식으로 한 함수가 끝나는 시간과 바로 다음 함수가 시작하는 시간이 동일하다.
- A가 끝나는 시간과 B가 시작하는 시간이 동일하다.
<img src="./image/20220930_Synchronous_v1.png">
- A와 B가 시작시간 또는 종로시간이 동일하다.
<img src="./image/20220930_Synchronous_v2.png">

- 비동기 방식은 여러 개의 처리가 함께 실행되는 방식으로 동기 방식에 비해 단위시간 당 많은 작업을 처리할 수 있다.
- 작업을 수행하는 주체의 시작시간과 상관없이 각자의 시작시간과 끝나는 시간을 가지고 있다.
<img src="./image/20220930_Asynchronous.png">

- CPU나 메모리를 많이 사용하는 작업을 비동기로 처리하면 과부하가 걸릴 수 있고 프로그램의 복잡도도 증가한다.

### Blocking / Non-Bloking
- 동기 비동기와 다름 관점으로 직접 제어할 수 없는 대상(IO/Multi-Thread)을 상대하는 방법에 대한 분류이다.
- Blocking은 대상의 작업이 끝날 때까지 제어권을 대상이 가지고 있는 것을 의미한다.
- Non-Blocking은 대상의 작업 완료여부와 상관없이 새로운 작업을 수행한다.

