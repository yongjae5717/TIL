# International Software Testing Qualifications Board

<details>
<summary> 
<font size="4em" color="red">
1장 테스팅의 기초
</font>
</summary>
<div>


<details>
<summary> 1.1 테스팅이란 무엇인가 ? </summary>
<div>

---
## 1.1 테스팅이란 무엇인가?
#### 품질을 평가하고, 운영 중 소프트웨어 장애의 발생 가능성을 줄이는 방법.
#### 다양한 활동을 포함하는 프로세스이며 테스트 실행(결과 확인 포함)은 그 많은 활동 중 하나일 뿐이다.
#### 동적 테스팅?
  - 테스트 대상 컴포넌트나 시스템을 실행하는 테스팅
#### 정적 테스팅?
  - 테스트 대상 컴포넌트나 시스템을 실행하지 않는 테스팅
#### 테스팅은 요구사항, 사용자 스토리, 그 외 명세의 베리피케이션(verification)에만 국한된 활동이 아니다.

---
### 1.1.1 목적
- 요구사항, 사용자 스토리, 설계 소스 코드 등과 같은 작업 산출물 평가에 의한 결함 예방
- 명시된 모든 요구사항이 충족되었는지 검증
- 테스트 대상의 완성 여부 확인과 사용자와 기타 이해관계자의 기대치대로 동작하는지 확인
- 테스트 대상의 품질 수준에 대한 자신감 획득
- 부적절한 소프트웨어 품질의 리스크 레벨 감소로 장애와 결함을 발견
- 이해관계자가 테스트 대상의 품질 수준을 결정하는 데에 필요한 충분한 정보 제공
- 계약/법률/규제 요구사항이나 표준의 준수 및 테스트 대상이 이러한 요구사항이나 표준을 준수하는지 확인

#### 참고
- 현재의 테스트 레벨과 사용하는 소프트웨어 개발 수명주기 모델에 따라 달라질 수 있다.
  - 목적
    - 컴포넌트 테스팅의 목적 중 하나는 내재되어 있는 결함을 최대한 조기에 가능한 많이 식별하고 수정하는 것일 수 있다.
    - 코드 커버리지를 높이는 것일 수도 있다.
    - 인수 테스팅의 주요 목적 중 하나는 시스템이 기대한 대로 동작하는지, 또 요구사항을 충족하는지 확인하는 것일 수 있다.
    - 특정 시점에 시스템을 배포하는 것에 대한 리스크 정보를 이해관계자에게 제공하는 것일 수 있다.

---
### 1.1.2 테스팅 vs 디버깅
#### 디버깅
- 소프트웨어 결함으로 인한 장애의 원인을 찾고 분석해서 수정하는 개발 활동
- 이후 실행되는 확인 테스팅에서 결함을 제대로 수정했는지 확인한다.
- 테스터가 초기 테스트와 마지막 확인 테스트를 담당하고 개발자는 디버깅 관련 컴포넌트 및 컴포넌트 통합 테스팅을 수행한다.
- 애자일 개발 및 소프트웨어 수명주기 모델에서는 디버깅과 컴포넌트 테스팅에 관여하기도 한다.

</div>
</details>

<details>
<summary> 1.2 테스팅이 왜 필요한가 ? </summary>
<div>

## 1.2 테스팅이 왜 필요한가 ?
#### 결함을 발견하고 또 발견된 결함을 수정하는 것은 컴포넌트나 시스템 품질에 기여하는 것이다.

#### 소프트웨어 테스팅이 계약/법적 요구사항이나 특정 산업 표준을 만족하기 위해 필요할수 있다.

---
### 1.2.1 성공을 위한 테스팅의 기여
- 적절한 테스트 기법을 적절한 테스트 전문성을 가지고 적절한 테스트 레벨과 개발 생명주기 단계에 적용하면, 소프트웨어와 시스템이 그런 문제를 안고 배포되는 경우를 줄일 수 있다.

---
### 1.2.2 품질 보증과 테스팅
#### 품질보증(QA)과 테스팅을 혼용해서 사용하는 경우가 많은데 어느정도 연관성이 존재하지만, 다른 개념이다.

#### 품질보증(QA)
- 적절한 품질 수준에 달성했는지 확신을 얻기 위해 적절한 프로세스를 준수하도록 하는 것에 초점을 두고 있다.
- 프로세스를 따를 경우, 해당 프로세스를 바탕으로 생성되는 작업 산출물의 품질은 더 월등한 경우가 많으며, 높은 작업 산출물 품질은 결함 예방에 도움이 된다.
- 결함의 원인을 찾아서 제거하기 위한 근본 원인 분석의 활용과 회고 회의의 결과를 적절하게 적용해서 프로세스를 개선하는 것도 중요한 사항들이다.
- 전반적인 프로세스의 올바른 수행 여부에 관심을 가지기 때문에 올바른 테스팅의 적용에도 관심을 가진다.

#### 테스팅 활동
- 전반적인 소프트웨어 개발 및 유지보수 프로세스의 일부이다.

---
### 1.2.3 오류, 결함, 장애
#### 요구사항을 도출하면서 범해진 오류는 요구사항 결함이 되며, 이런 결함은 프로그램 작성 시 오류를 일으켜 결국 코드 결함의 원인이 된다.

#### 대표적인 오류 발생 원인
- 시간적인 압박
- 사람의 실수
- 경험이나 기술 부족
- 프로젝트 참여자 간의 의사소통 문제
- 코드, 설계, 아키텍쳐의 복잡성, 사용하는 기술의 복잡도
- 시스템 내/외부 인터페이스 이해 부족이나 그 수가 많은 경우
- 새롭고 익숙하지 않은 기술

#### 장애는 코드 결함뿐만 아니라 환경 조건으로 인해 발생할 수 있다.
#### 테스트 결과가 기대한 것과 다르다고해서 무조건 장애가 있다고 볼 수 없다.

---
### 1.2.4 결함, 근본 원인, 결과
#### 결함의 근본원인은 해당 결함을 만들어낸 최초의 행동이나 조건을 말한다.
- 결함을 분석함으로써 근본 원인을 찾을 수 있으며, 차후 유사한 결함의 발생 가능성을 낮출 수 있다.
- 단 한 줄의 잘못된 코드로 인한 이자 지급 오류는 소비자 불만을 초래한다.
- 결함은 코드에 포함된 잘못된 계단식으며, 그것은 원인이 되는 최초 결함은 사용자 스토리의 모호성이다.

</div>
</details>


<details>
<summary> 1.3 테스팅의 7가지 원리</summary>
<div>

## 1.3 테스팅의 7가지 원리

---
### 1.3.1 테스팅은 결함이 존재함을 밝히는 활동이지, 결함이 없음을 밝히는 활동이 아니다.
- 테스팅은 소프트웨어에 발견되지 않은 결함의 존재 가능성을 줄일 수 있지만, 결함이 전혀 발견되지 않았다하더라도 해당 소프트웨어가 완벽하다는 뜻은 아니다.

---
### 1.3.2 완벽한 테스팅은 불가능하다.
- 완벽하게 테스트하고자 하기보다는 리스크 분석과 우선순위를 토대로한 테스트에 노력을 집중하는 것이 좋다.

---
### 1.3.3 조기 테스팅으로 시간과 비용을 절약할 수 있다.
- 초기부터 시작하는 테스팅을 시프트 레프트라고도 부른다.
- 소프트웨어 수명주기 초기부터 테스팅을 함으로써 나중에 큰 비용이 동반되는 수정을 줄이거나 없앨 수 있다.

---
### 1.3.4 결함은 집중된다.
- 예상 결함 집중 영역과 테스트와 운영 중 실제로 관측한 결함 집중 영역은 리스크 분석의 주요 입력값으로 사용된다.

---
### 1.3.5 살충제 패러독스에 유의하라
- 같은 테스트를 계속해서 반복 실행한다면, 결국 해당 테스트로는 결함을 더 이상 발견할 수 없게 된다.
  (살충제를 계속 사용하다 보면 결국 해충을 잡지 못하듯, 테스트도 반복하다 보면 결국 결함을 더 이상 찾지 못하게 된다.)
- 자동 리그레션 테스팅의 경우 리그레션 결함이 적다는 것을 의미할 수도 있다.

---
### 1.3.6 테스팅은 정황에 의존적이다.
- 테스팅은 정황에 따라 다르게 진행된다.
  - ex) 안전 최우선 산업에서 사용하는 제어 소프트웨어는 e-commerce 모바일 앱과는 다르게 테스트한다.
- 애자일 프로젝트에서는 테스팅은 순차적 소프트웨어 개발 수명주기 프로젝트에서의 테스팅과는 다르게 진행한다.

---
### 1.3.7 오류 부재는 궤변이다.
- 원리 1, 2에서 알 수 있듯이 원리 7은 불가능하다.
- 단순히 많은 결함을 발견하고 고쳤다고해서 시스템의 성공이 보장된다고 생각하는 것은 궤변(잘못된 믿음)이다.

</div>
</details>

<details>
<summary> 1.4 테스트 프로세스 </summary>
<div>

## 1.4 테스트 프로세스

### 정의: 설정한 목적의 달성 가능성을 높여주는 공통적인 테스트 활동 세트
- 주어진 상황에 맞는 구체적인 소프트웨어 테스트 프로세스는 다양한 변수에 따라 결정된다.

### 1.4.1 정황에 따른 테스트 프로세스
#### 조직의 테스트 프로세스에 영향을 줄 수 있는 정황 요소
- 사용 중인 소프트웨어 개발 수명주기 모델과 프로젝트 방법론
- 적용하고자 하는 테스트 레벨과 테스트 유형
- 제품 및 프로젝트 리스크
- 비지니스 도메인
- 다음과 같은 운영상의 제약사항
  - 예산과 자원
  - 일정
  - 복잡도
  - 계약 및 규제 요구사항
- 운영 정책과 프랙티스
- 준수해야 하는 내부 및 외부 표준

#### 테스트 프로세스의 일반적인 요소
- 테스트 활동과 작업
- 테스트 작업 산출물
- 테스트 베이시스와 테스트 작업 산출물 간의 추적성

#### 테스트 레벨과 유형에 상관없이, 테스트 베이시스에 대한 측정 가능한 커버리지 조건이 설정되어 있으면 매우 유용하다.
#### 커버리지 조건은 소프트웨어 테스트의 목적 달성 여부를 보여주는 활동의 주요 성능 지표(KPI, key performance indicator)로 사용하기 용이하다.

---
### 1.4.2 테스트 활동과 작업

#### 테스트 프로세스를 구성하는 주요 활동
- **테스트 계획**
  - 테스팅의 목적과 정황으로 인한 제약 사항을 고려해 테스트 목적을 달성하기 위해 필요한 접근법을 정의하는 활동을 포함한다.

- 테스트 모니터링과 제어
  - 테스트 모니터링: 테스트 계획에 정의된 테스트 모니터링 메트릭을 활용해 실제 진행 상황을 계획한 진척 상황과 지속적으로 비교하는 활동을 말한다.
  - 테스트 제어: 시간이 지나면서 업데이트될 수 있는 테스트 계획의 목적 달성을 위해 필요한 활동을 수행하는 것이다.
  - 특정 테스트 레벨에서 이루어진 테스트 실행의 종료 조건 평가
    - 명시된 커버리지 조건 대비 테스트 결과와 로그 확인
    - 테스트 결과와 로그를 기반으로 컴포넌트나 시스템의 품질 수준 평가
    - 추가 테스트 필요 여부 결정

- **테스트 분석**
  - 테스트 가능한 기능과 연관된 테스트 컨디션을 식별하기 위해 테스트 베이시스를 분석한다. 
  - 즉, 테스트 분석은 측정 가능한 커버리지 조건의 측면에서 "무엇을 테스트할지"를 결정하는 것이다.
  - 테스트 분석 주요 활동
    - 고려 중인 테스트 레벨에 적합한 테스트 베이시스 평가
    - 테스트 베이시스와 테스트 항목을 평가해서 다양한 형태의 결함 식별
    - 테스트할 기능과 기능 세트 식별
    - 테스트 베이시스를 평가하고 기능, 비기능, 구조 특성, 기타 비즈니스 기술 요소, 리스크 수준 등을 고려해서 각 기능에 대한 테스트 컨디션의 정의 및 우선순위 선정
    - 테스트 베이시의 개별 요소와 연관된 테스트 컨디션 간의 양방향 추적성 포착
  - 블랙박스, 화이트박스, 경험 기반 기법을 적용하면 주요 테스트 컨디션의 누락을 방지하고 더 정확하고 정밀한 테스트 컨디션 도출에 도움이 될 수 있다.
  - 분석의 결과로 테스트 차터의 테스트 목적으로 사용할 테스트 컨디션이 생성되는 경우도 있다.
  - 결함 식별은 큰 잠재적 이점이다.

- **테스트 설계**
  - 테스트 컨디션 기반으로 상위 수준 테스트 케이스, 상위 테스트 케이스 세트, 기타 테스트웨어를 생성한다.
  - 테스트 분석은 "무엇을 테스트할 것인가?"라는 질문에 답변하는 반면, 테스트 설계는 "어떻게 테스트할 것인가?"를 다루게 된다.

  - 주요 활동
    - 테스트 케이스와 테스트 케이스 세트 설계 및 우선순위 선정
    - 테스트 컨디션과 테스트케이스에 필요한 테스트 데이터 식별
    - 테스트 환경 설계와 필요한 인프라 및 도구 식별
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스 간의 양방향 추적성 설명

- **테스트 구현**
  - 테스트 구현 중 테스트 실행에 필요한 테스트웨어를 생성하고 완성하며, 테스트 케이스를 배치해서 테스트 프로시저를 만드는 것도 여기에 포함된다.
  - 테스트 구현은 "테스트를 실행하기 위해 필요한 모든 것이 갖춰져 있는가?"라는 질문에 답하는 활동이다.
  
  - 주요 활동
    - 테스트 프로시저의 개발과 우선순위 선정, 가능하다면 자동 테스트 스크립트 생성
    - 테스트 프로시저와 (있다면) 자동 테스트 스크립트로부터 테스트 스위트(test suite) 생성
    - 효과적인 테스트 실행이 가능하도록 테스트 스위트를 테스트 실행 일정 내에 배치 (5.2.4 절 참조)
    - 테스트 환경 구축, 가능하다면 테스트 하네스(test harness), 서비스 가상 현실화, 시뮬레이터, 기타 인프라 항목까지, 또 필요한 모든 사항을 제대로 구현했는지 확인
    - 테스트 데이터를 준비하고, 테스트 환경에 제대로 입력했는지 확인
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스, 테스트 프로시저, 테스트 스위트 서로 간의 양방향 추적성 검증과 업데이트 (1.4.4 절 참조)

  - 테스트 설계와 테스트 구현 작업은 합쳐지는 경우가 많다.
  - 탐색적 테스팅과 기타 경험 기반 테스팅 유형에서 테스트 설계와 구현이 테스트 실행의 일부로 이루어지거나 기록될 수 있다. 탐색적 테스팅은 테스트 분석에서 생성되는 테스트 차터를 기반으로 이루어질 수 있으며, 탐색적 테스트는 설계되고 구현되면서 바로 실행된다 (4.4.2 절 참조)

- **테스트 실행**
  - 테스트 스위트를 테스트 실행 일정에 따라 실행한다.
  - 주요 활동
    - 테스트 항목, 테스트 대상, 테스트 도구, 테스트웨어 등의 고유번호와 버전 기록
    - 테스트를 수동으로 혹은 테스트 실행 도구를 활용해서 실행
    - 기대 결과와 실제 결과 비교
    - 이상 현상을 분석해 원인 파악
    - 관찰한 장애를 기반으로 결함 보고
    - 테스트 실행 결과 기록
    - 이상 현상 때문에 취득한 활동의 결과로 인해 또는 계획된 테스팅의 일부로 테스트 활동 반복
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스, 테스트 프로시저, 테스트 결과 간의 양방향 추적성 검증과 업데이트

- **테스트 완료**
  - 완료한 테스트 활동에서 데이터를 수집해서 경험, 테스트웨어, 기타 관련 정보를 축적하는 활동이다.
  - 소프트웨어 시스템을 릴리스 했을 때, 테스트 프로젝트를 완료했을 때, 애자일 반복주기가 끝났을 때, 특정 테스트 레벨을 완료했을 때, 또는 유지보수 릴리스를 완료했을 때와 같은 프로젝트 마일스톤 시점에서 일어난다.
  - 주요 활동
    - 모든 결함 보고 처리를 완료했는지, 테스트 실행 후 해결되지 않은 모든 결함에 대해 수정 요청서 또는 프로젝트 백로그 항목을 생성했는지 확인
    - 이해관계자에게 전달할 테스트 요약 보고서 생성
    - 차후 재사용을 위해 테스트 환경, 테스트 인프라, 기타 테스트웨어의 마무리 및 보관
    - 테스트웨어를 유지보수팀, 다른 프로젝트팀, 그것을 활용할 수 있는 기타 이해관계자 등에게 인계
    - 완료한 테스트 활동을 통해 얻은 교훈을 분석해서 향후 반복주기, 릴리스, 또는 프로젝트를 위해 수정해야 하는 사항 판단
    - 테스트 프로세스 성숙도 개선을 위해 수집된 정보 활용

---
### 1.4.3 테스트 작업 산출물
#### 테스트 계획 작업 산출물
- 지속적, 장기적으로 생성되는 테스트 진행 현황 보고서와 다양한 테스트 완료 마일스톤에서 생성되는 테스트 요약 보고서와 같은 여러 형태의 테스트 보고서를 포함한다.
- 모든 테스트 보고서는 작성일 기준 테스트 진행 상황 관련 필요한 정보를 독자에게 제공해야 한다. (테스트 실행 결과가 나오면 그것에 대한 요약도 포함해야 한다.)
- 테스트 모니터링과 제어 작업 산출물은 작업 완료, 리소스 할당과 사용, 공수 등과 같이 프로젝트 관리에서 관심을 가지는 사항에 대해서도 다루어야 한다.
- 5.3 절에서 상세히 다루고 있다.

#### 테스트 분석 작업 산출물
- 이상적으로는 각 테스트 컨디션과 그것이 커버하는 테스트 베이시스 요소와의 양방향 추적성이 성립되어 있어야 한다.
- 탐색적 테스팅에서는 테스트 분석 중 테스트 차터를 생성할 수 있다.
- 테스트 분석에서 테스트 베이시스의 결함을 발견, 보고할 수 있다.

#### 테스트 설계 작업 산출물
- 테스트 분석에서 정의한 테스트 컨디션을 실행할 수 있는 테스트 케이스와 테스트 케이스 세트가 만들어진다.
- 이상적으로는 각각의 테스트 케이스와 그것이 커버하는 테스트 컨디션 간의 양방향 추적성이 성립되어 있어야 한다.
- 결과물
  - 필요한 테스트 데이터의 설계나 식별
  - 테스트 환경 설계
  - 인프라와 도구의 식별

#### 테스트 구현 작업 산출물
- 산출물
  - 테스트 프로시저와 이 프로시저의 배열
  - 테스트 스위트
  - 테스트 실행 일정

- 이상적인 상황에서는 테스트 구현이 끝나면, 테스트 케이스와 테스트 컨디션을 통해 테스트 프로시저와 테스트 베이시스
개별 요소 간의 양방향 추적성을 확인함으로써 테스트 계획에서 정의한 커버리지 조건의 달성 여부를 확인할 수 있다.
- 테스트 구현이 도구를 사용하거나 도구로 생성되는 작업 산출물을 포함하는 경우도 있다.
- 테스트 구현의 결과로 테스트 데이터와 테스트 환경을 구현 및 검증할 수도 있다.
- 테스트 데이터는 테스트 케이스의 입력값과 기대 결과값에 확정값을 할당하는 데 사용한다.
  (해당 값의 사용에 대한 세부적인 지침으로 이렇게 확정된 값은 상위 수준 테스트 케이스를 실행 가능한 하위 수준 테스트 케이스로 변화시킨다.
  테스트 대상의 다른 릴리스에 대해 같은 상위 수준 테스트 케이스를 실행할 경우 다른 테스트 데이터를 사용할 수 있다. 확정된 데이터에 대한 확정 기대 결과값은 테스트 오라클을 통해 식별할 수 있다.)
- 테스트 분석에서 정의한 테스트 컨디션은 테스트 구현 중 추가로 개선할 수 있다.

#### 테스트 실행 작업 산출물
- 산출물
  - 개별 테스트 케이스나 테스트 프로시저의 상태에 대한 문서
  - 결함 보고서
  - 테스팅에 사용한 테스트 항목, 테스트 대상, 테스트 도구, 테스트웨어 등에 대한 문서

- 이상적인 상황에서는, 테스트 실행이 끝나면 연관된 테스트 프로시저와의 양방향 추적성을 활용해서 테스트 베이시스 개별 요소의 상태에 대해 판단하고 보고할 수 있다.
- 커버리지 조건 충족 여부를 검증할 수 있으며, 테스트 결과를 이해관계자가 이해할 수 있는 형태로 보고할 수 있다.

#### 테스트 완료 작업 산출물
- 산출물
  - 테스트 요약 보고서
  - 차후 프로젝트나 반복주기의 개선을 위한 액션 아이템
  - 수정 요청서 혹은 제품 백로그 항목
  - 완성된 테스트웨어 등

---
### 1.4.4 테스트 베이시스와 테스트 작업 산출물 간의 추적성
#### 테스트 작업 산출물과 그 작업 산출물의 명칭은 매우 다양하다.
#### 비록 그렇다하더라도 효과적인 테스트 모니터링과 제어를 구현하기 위해서는 테스트 프로세스 전반에 걸쳐 테스트 베이시스의 개별 요소 및 해당 요소와 연관된 다양한 테스트 작업 산출물 간의 추적성을 확립하고 유지하는 것이 중요하다.
#### 좋은 추적성은 커버리지에 대한 평가를 가능하게 할 뿐만 아니라 아래와 같은 장점도 제공한다.
- 수정으로 인한 영향 평가
- 테스팅에 대한 감시
- IT 통제 조건 충족
- 테스트 베이시스 개별 요소의 상태에 대한 정보를 포함함으로써 테스트 진행 상황 보고서와 테스트 요약 보고서를 좀 더 쉽게 이해할 수 있다.
- 테스팅의 기술적인 내용을 이해관계자가 이해할 수 있는 형태로 전달한다.
- 비즈니스 목표 대비 제품 품질, 프로세스 역량, 프로젝트 진행 상황 등을 평가할 수 있는 정보를 제공한다.

</div>
</details>


<details>
<summary> 1.5 테스팅의 심리학 </summary>
<div>

## 1.5 테스팅의 심리학
### 소프트웨어 테스팅을 포함한 소프트웨어 개발은 사람이 하는 일이다.
### 따라서, 인간 심리학은 소프트웨어 테스팅에 중요한 영향을 미친다.

---
### 1.5.1 인간 심리학과 테스팅
#### 테스터와 테스트 관리자는 결함, 장애, 테스트 결과, 테스트 진행 상황, 리스크 등을 효과적으로 전달하기 위해, 또는 동료와 긍정적인 관계를 구축하기 위해 좋은 대인 관계 기술을 가질 필요가 없다.

#### 의사 소통을 더 잘할 수 있는 방법에 대한 예제
- 다툼 보다는 협력
- 테스팅의 이점을 강조
- 테스트 결과와 기타 발견 사항을 중립적이면서 사실에 기반을 둔 방법으로 전달해야 한다.
- 결함이 발생한 항목을 제작한 사람을 비판해서는 안 된다.
- 객관적이고 사실에 기반을 둔 결함 보고서와 리뷰 결과서를 작성하라
- 상대방이 어떤 느낌을 받을지, 또 해당 정보에 대해 부정적으로 반응하는 이유가 뭔지를 이해하려고 해야 한다.
- 상대방이 전달받을 내용을 이해했는지, 또 반대로 상대방이 하고자 하는 말을 제대로 이해했는지 확인하라.

#### 테스터는 개인의 성향은 최대한 배제하고 이런 목표와 부합하려고 하는 자세가 매우 중요하다.

---
### 1.5.2 테스터와 개발자의 사고방식
#### 테스팅의 목적은 제품에 대한 벨리데이션과 베리피케이션, 릴리스 전 결함 발견 등으로 다양한데, 목적이 다르기 때문에 필요한 사고 방식도 다르다. 이런 사고방식을 적절히 조합해서 사용하면 더 높은 수준의 제품 품질을 달성할 수 있다.

#### 테스터는 호기심, 전문적 비평(professional pessimism) 능력, 비판적 시각, 세밀한 것에 주목하는 태도, 긍정적인 의사소통과 관계 수립에 대한 동기 등의 사고방식을 가지고 있어야 한다. 이 테스터의 사고방식은 테스터가 경험을 쌓아감에 따라 점차 확대되고 성숙해지는 경향을 가지고 있다.

#### 개발자의 사고방식에도 테스터의 사고방식과 같은 요소가 일부 있을 수 있지만, 성공적인 개발자는 해결책을 설계하고 구축하는 데 더 관심을 기울이며 그런 해결책에 무슨 문제가 있는 지에 대해 관심을 가지는 경우는 많지 않다. 또한 확증 편향때문에 자신이 만든 오류에 대해 인지하기 어렵다.

</div>
</details>

</div>
</details>


<details>
<summary>
<font size="4em" color="orange">
2장 소프트웨어 개발 수명주기와 테스팅
</font>
</summary>
<div>


<details>
<summary> 2.1 소프트웨어 개발 수명주기 모델 </summary>
<div>

## 2.1 소프트웨어 개발 수명주기 모델
### 2.1.1 소프트웨어 개발과 소프트웨어 테스팅
#### 소프트웨어 개발 수명주기 모델을 잘 이해하는 것은 테스터의 중요한 역할이다 !

#### 소프트웨어 개발 수명주기 모델에 적용하기 좋은 테스팅의 특성
- 모든 개발 활동은 그에 상응하는 테스트 활동이 있다.
- 각 테스트 레벨은 그 레벨에 맞는 구체적인 목적을 가진다.
- 주어진 테스트 레벨에 맞는 테스트 분석과 설계는 상응하는 개발 활동이 이루어지고 있는 동안 시작해야 한다.
- 테스터가 요구사항과 설계의 정의와 개선을 위한 대화에 참여하고, 작업 산출물의 초안이 나오는 즉시 리뷰에 참여한다.

#### 시간과 비용을 절약할 수 있다는 테스트 원리에 따라, 테스트 활동은 수명주기 초반에 시작해야 한다.

#### 대표적인 소프트웨어 개발 수명주기 모델을 아래와 같이 분류하고 있다.
- `순차적 개발 모델`
  - 소프트웨어 개발 프로세스를 1차원적 선형의 순자적 활동으로 설명한다. (개발 프로세스의 모든 단계는 이전 단계가 완료될 때 시작되어야 한다.)
  - 완성된 기능 세트를 포함한 소프트웨어를 배포할 수 있지만, 일반적으로 이해관계자와 사용자에게 배포하기까지 몇 개월 또는 몇 년이 걸린다.
  - **폭포수 모델**에서는, 개발 활동이 순차적으로 이루어진다. 이 모델에서의 테스트 활동은 모든 개발 활동을 완료한 후에 이루어진다.
  - 폭포수 모델과는 다르게, V-모델은 테스팅을 초기에 시작하면 좋다는 원리를 토대로 테스트 프로세스를 전반적인 개발 프로세스에 통합한다.
  - **V-모델**은 대응하는 각 개발 단계에 테스트 레벨을 부여함으로써, 조기 테스팅을 좀 더 적극적으로 구현하고 있다.

- `반복적 점진적 개발 모델`
  - 요구사항 정의, 시스템의 설계, 구축, 테스팅을 조각으로 나눠서 진행한다.
  - 소프트웨어 기능은 점진적으로 늘어나게 된다. (이런 증분의 크기는 다양하게 설정할 수 있다.)
  - 기능 증분은 사용자 인터페이스 화면이나 신규 문의 옵션에 생기는 변경 하나만큼 작을 수 있다.
  - **대표적인 예**
  
  | 프로세스명       | 반복주기                                                                             | 기능증분                                        |
  |-------------|----------------------------------------------------------------------------------|---------------------------------------------|
  | 레셔널 통합 프로세스 | 상당히 긴 편(2, 3 개월)                                                                 | 상당히 큼                                       |
  | 스크럼         | 상당히 짧은 편 (몇 시간, 며칠, 또는 몇 주)                                                      | 작음(몇 가지 개선 사항 혹은 2, 3개의 신규 기능)              |
  | 칸반          | 고정된 경우와 않은 경우가 있으며, 각 반복주기는 완료 후 하나의 개선 사항이나 기능을 전달하거나 몇 개의 기능을 묶어 한번에 전달할 수 있음. | -                                           |
  | 나선형         | -                                                                                | 실험적인 증분을 생성 (일부는 차후 개발 과정에서 상당 부분 수정 or 폐기) |

  - 이런 방법을 사용하면 점진적으로 커지는 시스템을 만들 수 있으며, 해당 시스템은 최종 사용자에게 기능별, 반복주기별, 아니면 좀 더 전통적인 주요 릴리스 단위로 릴리스할 수 있다.

</div>
</details>

<details>
<summary> 2.2 테스트 레벨 </summary>
<div>

## 2.2 테스트 레벨
</div>
</details>

<details>
<summary> 2.3 테스트 유형 </summary>
<div>

## 2.3 테스트 유형

</div>
</details>

<details>
<summary> 2.4 유지보수 테스팅 </summary>
<div>

## 2.4 유지보수 테스팅

</div>
</details>


</div>
</details>
