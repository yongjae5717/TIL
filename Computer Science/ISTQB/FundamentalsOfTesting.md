# Fundamentals of Testing

<details>
<summary> 1.1 테스팅이란 무엇인가 ? </summary>
<div>

---
## 1.1 테스팅이란 무엇인가?
#### 품질을 평가하고, 운영 중 소프트웨어 장애의 발생 가능성을 줄이는 방법.
#### 다양한 활동을 포함하는 프로세스이며 테스트 실행(결과 확인 포함)은 그 많은 활동 중 하나일 뿐이다.
#### 동적 테스팅?
  - 테스트 대상 컴포넌트나 시스템을 실행하는 테스팅
#### 정적 테스팅?
  - 테스트 대상 컴포넌트나 시스템을 실행하지 않는 테스팅
#### 테스팅은 요구사항, 사용자 스토리, 그 외 명세의 베리피케이션(verification)에만 국한된 활동이 아니다.

---
### 1.1.1 목적
- 요구사항, 사용자 스토리, 설계 소스 코드 등과 같은 작업 산출물 평가에 의한 결함 예방
- 명시된 모든 요구사항이 충족되었는지 검증
- 테스트 대상의 완성 여부 확인과 사용자와 기타 이해관계자의 기대치대로 동작하는지 확인
- 테스트 대상의 품질 수준에 대한 자신감 획득
- 부적절한 소프트웨어 품질의 리스크 레벨 감소로 장애와 결함을 발견
- 이해관계자가 테스트 대상의 품질 수준을 결정하는 데에 필요한 충분한 정보 제공
- 계약/법률/규제 요구사항이나 표준의 준수 및 테스트 대상이 이러한 요구사항이나 표준을 준수하는지 확인

#### 참고
- 현재의 테스트 레벨과 사용하는 소프트웨어 개발 수명주기 모델에 따라 달라질 수 있다.
  - 목적
    - 컴포넌트 테스팅의 목적 중 하나는 내재되어 있는 결함을 최대한 조기에 가능한 많이 식별하고 수정하는 것일 수 있다.
    - 코드 커버리지를 높이는 것일 수도 있다.
    - 인수 테스팅의 주요 목적 중 하나는 시스템이 기대한 대로 동작하는지, 또 요구사항을 충족하는지 확인하는 것일 수 있다.
    - 특정 시점에 시스템을 배포하는 것에 대한 리스크 정보를 이해관계자에게 제공하는 것일 수 있다.

---
### 1.1.2 테스팅 vs 디버깅
#### 디버깅
- 소프트웨어 결함으로 인한 장애의 원인을 찾고 분석해서 수정하는 개발 활동
- 이후 실행되는 확인 테스팅에서 결함을 제대로 수정했는지 확인한다.
- 테스터가 초기 테스트와 마지막 확인 테스트를 담당하고 개발자는 디버깅 관련 컴포넌트 및 컴포넌트 통합 테스팅을 수행한다.
- 애자일 개발 및 소프트웨어 수명주기 모델에서는 디버깅과 컴포넌트 테스팅에 관여하기도 한다.

</div>
</details>

<details>
<summary> 1.2 테스팅이 왜 필요한가 ? </summary>
<div>

## 1.2 테스팅이 왜 필요한가 ?
#### 결함을 발견하고 또 발견된 결함을 수정하는 것은 컴포넌트나 시스템 품질에 기여하는 것이다.

#### 소프트웨어 테스팅이 계약/법적 요구사항이나 특정 산업 표준을 만족하기 위해 필요할수 있다.

---
### 1.2.1 성공을 위한 테스팅의 기여
- 적절한 테스트 기법을 적절한 테스트 전문성을 가지고 적절한 테스트 레벨과 개발 생명주기 단계에 적용하면, 소프트웨어와 시스템이 그런 문제를 안고 배포되는 경우를 줄일 수 있다.

---
### 1.2.2 품질 보증과 테스팅
#### 품질보증(QA)과 테스팅을 혼용해서 사용하는 경우가 많은데 어느정도 연관성이 존재하지만, 다른 개념이다.

#### 품질보증(QA)
- 적절한 품질 수준에 달성했는지 확신을 얻기 위해 적절한 프로세스를 준수하도록 하는 것에 초점을 두고 있다.
- 프로세스를 따를 경우, 해당 프로세스를 바탕으로 생성되는 작업 산출물의 품질은 더 월등한 경우가 많으며, 높은 작업 산출물 품질은 결함 예방에 도움이 된다.
- 결함의 원인을 찾아서 제거하기 위한 근본 원인 분석의 활용과 회고 회의의 결과를 적절하게 적용해서 프로세스를 개선하는 것도 중요한 사항들이다.
- 전반적인 프로세스의 올바른 수행 여부에 관심을 가지기 때문에 올바른 테스팅의 적용에도 관심을 가진다.

#### 테스팅 활동
- 전반적인 소프트웨어 개발 및 유지보수 프로세스의 일부이다.

---
### 1.2.3 오류, 결함, 장애
#### 요구사항을 도출하면서 범해진 오류는 요구사항 결함이 되며, 이런 결함은 프로그램 작성 시 오류를 일으켜 결국 코드 결함의 원인이 된다.

#### 대표적인 오류 발생 원인
- 시간적인 압박
- 사람의 실수
- 경험이나 기술 부족
- 프로젝트 참여자 간의 의사소통 문제
- 코드, 설계, 아키텍쳐의 복잡성, 사용하는 기술의 복잡도
- 시스템 내/외부 인터페이스 이해 부족이나 그 수가 많은 경우
- 새롭고 익숙하지 않은 기술

#### 장애는 코드 결함뿐만 아니라 환경 조건으로 인해 발생할 수 있다.
#### 테스트 결과가 기대한 것과 다르다고해서 무조건 장애가 있다고 볼 수 없다.

---
### 1.2.4 결함, 근본 원인, 결과
#### 결함의 근본원인은 해당 결함을 만들어낸 최초의 행동이나 조건을 말한다.
- 결함을 분석함으로써 근본 원인을 찾을 수 있으며, 차후 유사한 결함의 발생 가능성을 낮출 수 있다.
- 단 한 줄의 잘못된 코드로 인한 이자 지급 오류는 소비자 불만을 초래한다.
- 결함은 코드에 포함된 잘못된 계단식으며, 그것은 원인이 되는 최초 결함은 사용자 스토리의 모호성이다.

</div>
</details>


<details>
<summary> 1.3 테스팅의 7가지 원리</summary>
<div>

## 1.3 테스팅의 7가지 원리

---
### 1.3.1 테스팅은 결함이 존재함을 밝히는 활동이지, 결함이 없음을 밝히는 활동이 아니다.
- 테스팅은 소프트웨어에 발견되지 않은 결함의 존재 가능성을 줄일 수 있지만, 결함이 전혀 발견되지 않았다하더라도 해당 소프트웨어가 완벽하다는 뜻은 아니다.

---
### 1.3.2 완벽한 테스팅은 불가능하다.
- 완벽하게 테스트하고자 하기보다는 리스크 분석과 우선순위를 토대로한 테스트에 노력을 집중하는 것이 좋다.

---
### 1.3.3 조기 테스팅으로 시간과 비용을 절약할 수 있다.
- 초기부터 시작하는 테스팅을 시프트 레프트라고도 부른다.
- 소프트웨어 수명주기 초기부터 테스팅을 함으로써 나중에 큰 비용이 동반되는 수정을 줄이거나 없앨 수 있다.

---
### 1.3.4 결함은 집중된다.
- 예상 결함 집중 영역과 테스트와 운영 중 실제로 관측한 결함 집중 영역은 리스크 분석의 주요 입력값으로 사용된다.

---
### 1.3.5 살충제 패러독스에 유의하라
- 같은 테스트를 계속해서 반복 실행한다면, 결국 해당 테스트로는 결함을 더 이상 발견할 수 없게 된다.
  (살충제를 계속 사용하다 보면 결국 해충을 잡지 못하듯, 테스트도 반복하다 보면 결국 결함을 더 이상 찾지 못하게 된다.)
- 자동 리그레션 테스팅의 경우 리그레션 결함이 적다는 것을 의미할 수도 있다.

---
### 1.3.6 테스팅은 정황에 의존적이다.
- 테스팅은 정황에 따라 다르게 진행된다.
  - ex) 안전 최우선 산업에서 사용하는 제어 소프트웨어는 e-commerce 모바일 앱과는 다르게 테스트한다.
- 애자일 프로젝트에서는 테스팅은 순차적 소프트웨어 개발 수명주기 프로젝트에서의 테스팅과는 다르게 진행한다.

---
### 1.3.7 오류 부재는 궤변이다.
- 원리 1, 2에서 알 수 있듯이 원리 7은 불가능하다.
- 단순히 많은 결함을 발견하고 고쳤다고해서 시스템의 성공이 보장된다고 생각하는 것은 궤변(잘못된 믿음)이다.

</div>
</details>

<details>
<summary> 1.4 테스트 프로세스 </summary>
<div>

## 1.4 테스트 프로세스

### 정의: 설정한 목적의 달성 가능성을 높여주는 공통적인 테스트 활동 세트
- 주어진 상황에 맞는 구체적인 소프트웨어 테스트 프로세스는 다양한 변수에 따라 결정된다.

### 1.4.1 정황에 따른 테스트 프로세스
#### 조직의 테스트 프로세스에 영향을 줄 수 있는 정황 요소
- 사용 중인 소프트웨어 개발 수명주기 모델과 프로젝트 방법론
- 적용하고자 하는 테스트 레벨과 테스트 유형
- 제품 및 프로젝트 리스크
- 비지니스 도메인
- 다음과 같은 운영상의 제약사항
  - 예산과 자원
  - 일정
  - 복잡도
  - 계약 및 규제 요구사항
- 운영 정책과 프랙티스
- 준수해야 하는 내부 및 외부 표준

#### 테스트 프로세스의 일반적인 요소
- 테스트 활동과 작업
- 테스트 작업 산출물
- 테스트 베이시스와 테스트 작업 산출물 간의 추적성

#### 테스트 레벨과 유형에 상관없이, 테스트 베이시스에 대한 측정 가능한 커버리지 조건이 설정되어 있으면 매우 유용하다.
#### 커버리지 조건은 소프트웨어 테스트의 목적 달성 여부를 보여주는 활동의 주요 성능 지표(KPI, key performance indicator)로 사용하기 용이하다.

---
### 1.4.2 테스트 활동과 작업

#### 테스트 프로세스를 구성하는 주요 활동
- **테스트 계획**
  - 테스팅의 목적과 정황으로 인한 제약 사항을 고려해 테스트 목적을 달성하기 위해 필요한 접근법을 정의하는 활동을 포함한다.

- 테스트 모니터링과 제어
  - 테스트 모니터링: 테스트 계획에 정의된 테스트 모니터링 메트릭을 활용해 실제 진행 상황을 계획한 진척 상황과 지속적으로 비교하는 활동을 말한다.
  - 테스트 제어: 시간이 지나면서 업데이트될 수 있는 테스트 계획의 목적 달성을 위해 필요한 활동을 수행하는 것이다.
  - 특정 테스트 레벨에서 이루어진 테스트 실행의 종료 조건 평가
    - 명시된 커버리지 조건 대비 테스트 결과와 로그 확인
    - 테스트 결과와 로그를 기반으로 컴포넌트나 시스템의 품질 수준 평가
    - 추가 테스트 필요 여부 결정

- **테스트 분석**
  - 테스트 가능한 기능과 연관된 테스트 컨디션을 식별하기 위해 테스트 베이시스를 분석한다. 
  - 즉, 테스트 분석은 측정 가능한 커버리지 조건의 측면에서 "무엇을 테스트할지"를 결정하는 것이다.
  - 테스트 분석 주요 활동
    - 고려 중인 테스트 레벨에 적합한 테스트 베이시스 평가
    - 테스트 베이시스와 테스트 항목을 평가해서 다양한 형태의 결함 식별
    - 테스트할 기능과 기능 세트 식별
    - 테스트 베이시스를 평가하고 기능, 비기능, 구조 특성, 기타 비즈니스 기술 요소, 리스크 수준 등을 고려해서 각 기능에 대한 테스트 컨디션의 정의 및 우선순위 선정
    - 테스트 베이시의 개별 요소와 연관된 테스트 컨디션 간의 양방향 추적성 포착
  - 블랙박스, 화이트박스, 경험 기반 기법을 적용하면 주요 테스트 컨디션의 누락을 방지하고 더 정확하고 정밀한 테스트 컨디션 도출에 도움이 될 수 있다.
  - 분석의 결과로 테스트 차터의 테스트 목적으로 사용할 테스트 컨디션이 생성되는 경우도 있다.
  - 결함 식별은 큰 잠재적 이점이다.

- **테스트 설계**
  - 테스트 컨디션 기반으로 상위 수준 테스트 케이스, 상위 테스트 케이스 세트, 기타 테스트웨어를 생성한다.
  - 테스트 분석은 "무엇을 테스트할 것인가?"라는 질문에 답변하는 반면, 테스트 설계는 "어떻게 테스트할 것인가?"를 다루게 된다.

  - 주요 활동
    - 테스트 케이스와 테스트 케이스 세트 설계 및 우선순위 선정
    - 테스트 컨디션과 테스트케이스에 필요한 테스트 데이터 식별
    - 테스트 환경 설계와 필요한 인프라 및 도구 식별
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스 간의 양방향 추적성 설명

- **테스트 구현**
  - 테스트 구현 중 테스트 실행에 필요한 테스트웨어를 생성하고 완성하며, 테스트 케이스를 배치해서 테스트 프로시저를 만드는 것도 여기에 포함된다.
  - 테스트 구현은 "테스트를 실행하기 위해 필요한 모든 것이 갖춰져 있는가?"라는 질문에 답하는 활동이다.
  
  - 주요 활동
    - 테스트 프로시저의 개발과 우선순위 선정, 가능하다면 자동 테스트 스크립트 생성
    - 테스트 프로시저와 (있다면) 자동 테스트 스크립트로부터 테스트 스위트(test suite) 생성
    - 효과적인 테스트 실행이 가능하도록 테스트 스위트를 테스트 실행 일정 내에 배치 (5.2.4 절 참조)
    - 테스트 환경 구축, 가능하다면 테스트 하네스(test harness), 서비스 가상 현실화, 시뮬레이터, 기타 인프라 항목까지, 또 필요한 모든 사항을 제대로 구현했는지 확인
    - 테스트 데이터를 준비하고, 테스트 환경에 제대로 입력했는지 확인
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스, 테스트 프로시저, 테스트 스위트 서로 간의 양방향 추적성 검증과 업데이트 (1.4.4 절 참조)

  - 테스트 설계와 테스트 구현 작업은 합쳐지는 경우가 많다.
  - 탐색적 테스팅과 기타 경험 기반 테스팅 유형에서 테스트 설계와 구현이 테스트 실행의 일부로 이루어지거나 기록될 수 있다. 탐색적 테스팅은 테스트 분석에서 생성되는 테스트 차터를 기반으로 이루어질 수 있으며, 탐색적 테스트는 설계되고 구현되면서 바로 실행된다 (4.4.2 절 참조)

- **테스트 실행**
  - 테스트 스위트를 테스트 실행 일정에 따라 실행한다.
  - 주요 활동
    - 테스트 항목, 테스트 대상, 테스트 도구, 테스트웨어 등의 고유번호와 버전 기록
    - 테스트를 수동으로 혹은 테스트 실행 도구를 활용해서 실행
    - 기대 결과와 실제 결과 비교
    - 이상 현상을 분석해 원인 파악
    - 관찰한 장애를 기반으로 결함 보고
    - 테스트 실행 결과 기록
    - 이상 현상 때문에 취득한 활동의 결과로 인해 또는 계획된 테스팅의 일부로 테스트 활동 반복
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스, 테스트 프로시저, 테스트 결과 간의 양방향 추적성 검증과 업데이트

- **테스트 완료**
  - 완료한 테스트 활동에서 데이터를 수집해서 경험, 테스트웨어, 기타 관련 정보를 축적하는 활동이다.
  - 소프트웨어 시스템을 릴리스 했을 때, 테스트 프로젝트를 완료했을 때, 애자일 반복주기가 끝났을 때, 특정 테스트 레벨을 완료했을 때, 또는 유지보수 릴리스를 완료했을 때와 같은 프로젝트 마일스톤 시점에서 일어난다.
  - 주요 활동
    - 모든 결함 보고 처리를 완료했는지, 테스트 실행 후 해결되지 않은 모든 결함에 대해 수정 요청서 또는 프로젝트 백로그 항목을 생성했는지 확인
    - 이해관계자에게 전달할 테스트 요약 보고서 생성
    - 차후 재사용을 위해 테스트 환경, 테스트 인프라, 기타 테스트웨어의 마무리 및 보관
    - 테스트웨어를 유지보수팀, 다른 프로젝트팀, 그것을 활용할 수 있는 기타 이해관계자 등에게 인계
    - 완료한 테스트 활동을 통해 얻은 교훈을 분석해서 향후 반복주기, 릴리스, 또는 프로젝트를 위해 수정해야 하는 사항 판단
    - 테스트 프로세스 성숙도 개선을 위해 수집된 정보 활용


</div>
</details>


<details>
<summary> 예시: 더보기 </summary>
<div>

</div>
</details>
