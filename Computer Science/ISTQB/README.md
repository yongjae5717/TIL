# International Software Testing Qualifications Board

### This markdown file is a summary of studying ISTQB. The copyright is in the "ISTQB".

---
<details>
<summary> 
<font size="4em" color="red">
1장 테스팅의 기초
</font>
</summary>
<div>


<details>
<summary> 1.1 테스팅이란 무엇인가 ? </summary>
<div>

---
## 1.1 테스팅이란 무엇인가?
#### 품질을 평가하고, 운영 중 소프트웨어 장애의 발생 가능성을 줄이는 방법.
#### 다양한 활동을 포함하는 프로세스이며 테스트 실행(결과 확인 포함)은 그 많은 활동 중 하나일 뿐이다.
#### 동적 테스팅?
  - 테스트 대상 컴포넌트나 시스템을 실행하는 테스팅
#### 정적 테스팅?
  - 테스트 대상 컴포넌트나 시스템을 실행하지 않는 테스팅
#### 테스팅은 요구사항, 사용자 스토리, 그 외 명세의 베리피케이션(verification)에만 국한된 활동이 아니다.

---
### 1.1.1 목적
- 요구사항, 사용자 스토리, 설계 소스 코드 등과 같은 작업 산출물 평가에 의한 결함 예방
- 명시된 모든 요구사항이 충족되었는지 검증
- 테스트 대상의 완성 여부 확인과 사용자와 기타 이해관계자의 기대치대로 동작하는지 확인
- 테스트 대상의 품질 수준에 대한 자신감 획득
- 부적절한 소프트웨어 품질의 리스크 레벨 감소로 장애와 결함을 발견
- 이해관계자가 테스트 대상의 품질 수준을 결정하는 데에 필요한 충분한 정보 제공
- 계약/법률/규제 요구사항이나 표준의 준수 및 테스트 대상이 이러한 요구사항이나 표준을 준수하는지 확인

#### 참고
- 현재의 테스트 레벨과 사용하는 소프트웨어 개발 수명주기 모델에 따라 달라질 수 있다.
  - 목적
    - 컴포넌트 테스팅의 목적 중 하나는 내재되어 있는 결함을 최대한 조기에 가능한 많이 식별하고 수정하는 것일 수 있다.
    - 코드 커버리지를 높이는 것일 수도 있다.
    - 인수 테스팅의 주요 목적 중 하나는 시스템이 기대한 대로 동작하는지, 또 요구사항을 충족하는지 확인하는 것일 수 있다.
    - 특정 시점에 시스템을 배포하는 것에 대한 리스크 정보를 이해관계자에게 제공하는 것일 수 있다.

---
### 1.1.2 테스팅 vs 디버깅
#### 디버깅
- 소프트웨어 결함으로 인한 장애의 원인을 찾고 분석해서 수정하는 개발 활동
- 이후 실행되는 확인 테스팅에서 결함을 제대로 수정했는지 확인한다.
- 테스터가 초기 테스트와 마지막 확인 테스트를 담당하고 개발자는 디버깅 관련 컴포넌트 및 컴포넌트 통합 테스팅을 수행한다.
- 애자일 개발 및 소프트웨어 수명주기 모델에서는 디버깅과 컴포넌트 테스팅에 관여하기도 한다.

</div>
</details>

<details>
<summary> 1.2 테스팅이 왜 필요한가 ? </summary>
<div>

## 1.2 테스팅이 왜 필요한가 ?
#### 결함을 발견하고 또 발견된 결함을 수정하는 것은 컴포넌트나 시스템 품질에 기여하는 것이다.

#### 소프트웨어 테스팅이 계약/법적 요구사항이나 특정 산업 표준을 만족하기 위해 필요할수 있다.

---
### 1.2.1 성공을 위한 테스팅의 기여
- 적절한 테스트 기법을 적절한 테스트 전문성을 가지고 적절한 테스트 레벨과 개발 생명주기 단계에 적용하면, 소프트웨어와 시스템이 그런 문제를 안고 배포되는 경우를 줄일 수 있다.

---
### 1.2.2 품질 보증과 테스팅
#### 품질보증(QA)과 테스팅을 혼용해서 사용하는 경우가 많은데 어느정도 연관성이 존재하지만, 다른 개념이다.

#### 품질보증(QA)
- 적절한 품질 수준에 달성했는지 확신을 얻기 위해 적절한 프로세스를 준수하도록 하는 것에 초점을 두고 있다.
- 프로세스를 따를 경우, 해당 프로세스를 바탕으로 생성되는 작업 산출물의 품질은 더 월등한 경우가 많으며, 높은 작업 산출물 품질은 결함 예방에 도움이 된다.
- 결함의 원인을 찾아서 제거하기 위한 근본 원인 분석의 활용과 회고 회의의 결과를 적절하게 적용해서 프로세스를 개선하는 것도 중요한 사항들이다.
- 전반적인 프로세스의 올바른 수행 여부에 관심을 가지기 때문에 올바른 테스팅의 적용에도 관심을 가진다.

#### 테스팅 활동
- 전반적인 소프트웨어 개발 및 유지보수 프로세스의 일부이다.

---
### 1.2.3 오류, 결함, 장애
#### 요구사항을 도출하면서 범해진 오류는 요구사항 결함이 되며, 이런 결함은 프로그램 작성 시 오류를 일으켜 결국 코드 결함의 원인이 된다.

#### 대표적인 오류 발생 원인
- 시간적인 압박
- 사람의 실수
- 경험이나 기술 부족
- 프로젝트 참여자 간의 의사소통 문제
- 코드, 설계, 아키텍쳐의 복잡성, 사용하는 기술의 복잡도
- 시스템 내/외부 인터페이스 이해 부족이나 그 수가 많은 경우
- 새롭고 익숙하지 않은 기술

#### 장애는 코드 결함뿐만 아니라 환경 조건으로 인해 발생할 수 있다.
#### 테스트 결과가 기대한 것과 다르다고해서 무조건 장애가 있다고 볼 수 없다.

---
### 1.2.4 결함, 근본 원인, 결과
#### 결함의 근본원인은 해당 결함을 만들어낸 최초의 행동이나 조건을 말한다.
- 결함을 분석함으로써 근본 원인을 찾을 수 있으며, 차후 유사한 결함의 발생 가능성을 낮출 수 있다.
- 단 한 줄의 잘못된 코드로 인한 이자 지급 오류는 소비자 불만을 초래한다.
- 결함은 코드에 포함된 잘못된 계단식으며, 그것은 원인이 되는 최초 결함은 사용자 스토리의 모호성이다.

</div>
</details>


<details>
<summary> 1.3 테스팅의 7가지 원리</summary>
<div>

## 1.3 테스팅의 7가지 원리

---
### 1.3.1 테스팅은 결함이 존재함을 밝히는 활동이지, 결함이 없음을 밝히는 활동이 아니다.
- 테스팅은 소프트웨어에 발견되지 않은 결함의 존재 가능성을 줄일 수 있지만, 결함이 전혀 발견되지 않았다하더라도 해당 소프트웨어가 완벽하다는 뜻은 아니다.

---
### 1.3.2 완벽한 테스팅은 불가능하다.
- 완벽하게 테스트하고자 하기보다는 리스크 분석과 우선순위를 토대로한 테스트에 노력을 집중하는 것이 좋다.

---
### 1.3.3 조기 테스팅으로 시간과 비용을 절약할 수 있다.
- 초기부터 시작하는 테스팅을 시프트 레프트라고도 부른다.
- 소프트웨어 수명주기 초기부터 테스팅을 함으로써 나중에 큰 비용이 동반되는 수정을 줄이거나 없앨 수 있다.

---
### 1.3.4 결함은 집중된다.
- 예상 결함 집중 영역과 테스트와 운영 중 실제로 관측한 결함 집중 영역은 리스크 분석의 주요 입력값으로 사용된다.

---
### 1.3.5 살충제 패러독스에 유의하라
- 같은 테스트를 계속해서 반복 실행한다면, 결국 해당 테스트로는 결함을 더 이상 발견할 수 없게 된다.
  (살충제를 계속 사용하다 보면 결국 해충을 잡지 못하듯, 테스트도 반복하다 보면 결국 결함을 더 이상 찾지 못하게 된다.)
- 자동 리그레션 테스팅의 경우 리그레션 결함이 적다는 것을 의미할 수도 있다.

---
### 1.3.6 테스팅은 정황에 의존적이다.
- 테스팅은 정황에 따라 다르게 진행된다.
  - ex) 안전 최우선 산업에서 사용하는 제어 소프트웨어는 e-commerce 모바일 앱과는 다르게 테스트한다.
- 애자일 프로젝트에서는 테스팅은 순차적 소프트웨어 개발 수명주기 프로젝트에서의 테스팅과는 다르게 진행한다.

---
### 1.3.7 오류 부재는 궤변이다.
- 원리 1, 2에서 알 수 있듯이 원리 7은 불가능하다.
- 단순히 많은 결함을 발견하고 고쳤다고해서 시스템의 성공이 보장된다고 생각하는 것은 궤변(잘못된 믿음)이다.

</div>
</details>

<details>
<summary> 1.4 테스트 프로세스 </summary>
<div>

## 1.4 테스트 프로세스

### 정의: 설정한 목적의 달성 가능성을 높여주는 공통적인 테스트 활동 세트
- 주어진 상황에 맞는 구체적인 소프트웨어 테스트 프로세스는 다양한 변수에 따라 결정된다.

### 1.4.1 정황에 따른 테스트 프로세스
#### 조직의 테스트 프로세스에 영향을 줄 수 있는 정황 요소
- 사용 중인 소프트웨어 개발 수명주기 모델과 프로젝트 방법론
- 적용하고자 하는 테스트 레벨과 테스트 유형
- 제품 및 프로젝트 리스크
- 비지니스 도메인
- 다음과 같은 운영상의 제약사항
  - 예산과 자원
  - 일정
  - 복잡도
  - 계약 및 규제 요구사항
- 운영 정책과 프랙티스
- 준수해야 하는 내부 및 외부 표준

#### 테스트 프로세스의 일반적인 요소
- 테스트 활동과 작업
- 테스트 작업 산출물
- 테스트 베이시스와 테스트 작업 산출물 간의 추적성

#### 테스트 레벨과 유형에 상관없이, 테스트 베이시스에 대한 측정 가능한 커버리지 조건이 설정되어 있으면 매우 유용하다.
#### 커버리지 조건은 소프트웨어 테스트의 목적 달성 여부를 보여주는 활동의 주요 성능 지표(KPI, key performance indicator)로 사용하기 용이하다.

---
### 1.4.2 테스트 활동과 작업

#### 테스트 프로세스를 구성하는 주요 활동
- **테스트 계획**
  - 테스팅의 목적과 정황으로 인한 제약 사항을 고려해 테스트 목적을 달성하기 위해 필요한 접근법을 정의하는 활동을 포함한다.

- 테스트 모니터링과 제어
  - 테스트 모니터링: 테스트 계획에 정의된 테스트 모니터링 메트릭을 활용해 실제 진행 상황을 계획한 진척 상황과 지속적으로 비교하는 활동을 말한다.
  - 테스트 제어: 시간이 지나면서 업데이트될 수 있는 테스트 계획의 목적 달성을 위해 필요한 활동을 수행하는 것이다.
  - 특정 테스트 레벨에서 이루어진 테스트 실행의 종료 조건 평가
    - 명시된 커버리지 조건 대비 테스트 결과와 로그 확인
    - 테스트 결과와 로그를 기반으로 컴포넌트나 시스템의 품질 수준 평가
    - 추가 테스트 필요 여부 결정

- **테스트 분석**
  - 테스트 가능한 기능과 연관된 테스트 컨디션을 식별하기 위해 테스트 베이시스를 분석한다. 
  - 즉, 테스트 분석은 측정 가능한 커버리지 조건의 측면에서 "무엇을 테스트할지"를 결정하는 것이다.
  - 테스트 분석 주요 활동
    - 고려 중인 테스트 레벨에 적합한 테스트 베이시스 평가
    - 테스트 베이시스와 테스트 항목을 평가해서 다양한 형태의 결함 식별
    - 테스트할 기능과 기능 세트 식별
    - 테스트 베이시스를 평가하고 기능, 비기능, 구조 특성, 기타 비즈니스 기술 요소, 리스크 수준 등을 고려해서 각 기능에 대한 테스트 컨디션의 정의 및 우선순위 선정
    - 테스트 베이시의 개별 요소와 연관된 테스트 컨디션 간의 양방향 추적성 포착
  - 블랙박스, 화이트박스, 경험 기반 기법을 적용하면 주요 테스트 컨디션의 누락을 방지하고 더 정확하고 정밀한 테스트 컨디션 도출에 도움이 될 수 있다.
  - 분석의 결과로 테스트 차터의 테스트 목적으로 사용할 테스트 컨디션이 생성되는 경우도 있다.
  - 결함 식별은 큰 잠재적 이점이다.

- **테스트 설계**
  - 테스트 컨디션 기반으로 상위 수준 테스트 케이스, 상위 테스트 케이스 세트, 기타 테스트웨어를 생성한다.
  - 테스트 분석은 "무엇을 테스트할 것인가?"라는 질문에 답변하는 반면, 테스트 설계는 "어떻게 테스트할 것인가?"를 다루게 된다.

  - 주요 활동
    - 테스트 케이스와 테스트 케이스 세트 설계 및 우선순위 선정
    - 테스트 컨디션과 테스트케이스에 필요한 테스트 데이터 식별
    - 테스트 환경 설계와 필요한 인프라 및 도구 식별
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스 간의 양방향 추적성 설명

- **테스트 구현**
  - 테스트 구현 중 테스트 실행에 필요한 테스트웨어를 생성하고 완성하며, 테스트 케이스를 배치해서 테스트 프로시저를 만드는 것도 여기에 포함된다.
  - 테스트 구현은 "테스트를 실행하기 위해 필요한 모든 것이 갖춰져 있는가?"라는 질문에 답하는 활동이다.
  
  - 주요 활동
    - 테스트 프로시저의 개발과 우선순위 선정, 가능하다면 자동 테스트 스크립트 생성
    - 테스트 프로시저와 (있다면) 자동 테스트 스크립트로부터 테스트 스위트(test suite) 생성
    - 효과적인 테스트 실행이 가능하도록 테스트 스위트를 테스트 실행 일정 내에 배치 (5.2.4 절 참조)
    - 테스트 환경 구축, 가능하다면 테스트 하네스(test harness), 서비스 가상 현실화, 시뮬레이터, 기타 인프라 항목까지, 또 필요한 모든 사항을 제대로 구현했는지 확인
    - 테스트 데이터를 준비하고, 테스트 환경에 제대로 입력했는지 확인
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스, 테스트 프로시저, 테스트 스위트 서로 간의 양방향 추적성 검증과 업데이트 (1.4.4 절 참조)

  - 테스트 설계와 테스트 구현 작업은 합쳐지는 경우가 많다.
  - 탐색적 테스팅과 기타 경험 기반 테스팅 유형에서 테스트 설계와 구현이 테스트 실행의 일부로 이루어지거나 기록될 수 있다. 탐색적 테스팅은 테스트 분석에서 생성되는 테스트 차터를 기반으로 이루어질 수 있으며, 탐색적 테스트는 설계되고 구현되면서 바로 실행된다 (4.4.2 절 참조)

- **테스트 실행**
  - 테스트 스위트를 테스트 실행 일정에 따라 실행한다.
  - 주요 활동
    - 테스트 항목, 테스트 대상, 테스트 도구, 테스트웨어 등의 고유번호와 버전 기록
    - 테스트를 수동으로 혹은 테스트 실행 도구를 활용해서 실행
    - 기대 결과와 실제 결과 비교
    - 이상 현상을 분석해 원인 파악
    - 관찰한 장애를 기반으로 결함 보고
    - 테스트 실행 결과 기록
    - 이상 현상 때문에 취득한 활동의 결과로 인해 또는 계획된 테스팅의 일부로 테스트 활동 반복
    - 테스트 베이시스, 테스트 컨디션, 테스트 케이스, 테스트 프로시저, 테스트 결과 간의 양방향 추적성 검증과 업데이트

- **테스트 완료**
  - 완료한 테스트 활동에서 데이터를 수집해서 경험, 테스트웨어, 기타 관련 정보를 축적하는 활동이다.
  - 소프트웨어 시스템을 릴리스 했을 때, 테스트 프로젝트를 완료했을 때, 애자일 반복주기가 끝났을 때, 특정 테스트 레벨을 완료했을 때, 또는 유지보수 릴리스를 완료했을 때와 같은 프로젝트 마일스톤 시점에서 일어난다.
  - 주요 활동
    - 모든 결함 보고 처리를 완료했는지, 테스트 실행 후 해결되지 않은 모든 결함에 대해 수정 요청서 또는 프로젝트 백로그 항목을 생성했는지 확인
    - 이해관계자에게 전달할 테스트 요약 보고서 생성
    - 차후 재사용을 위해 테스트 환경, 테스트 인프라, 기타 테스트웨어의 마무리 및 보관
    - 테스트웨어를 유지보수팀, 다른 프로젝트팀, 그것을 활용할 수 있는 기타 이해관계자 등에게 인계
    - 완료한 테스트 활동을 통해 얻은 교훈을 분석해서 향후 반복주기, 릴리스, 또는 프로젝트를 위해 수정해야 하는 사항 판단
    - 테스트 프로세스 성숙도 개선을 위해 수집된 정보 활용

---
### 1.4.3 테스트 작업 산출물
#### 테스트 계획 작업 산출물
- 지속적, 장기적으로 생성되는 테스트 진행 현황 보고서와 다양한 테스트 완료 마일스톤에서 생성되는 테스트 요약 보고서와 같은 여러 형태의 테스트 보고서를 포함한다.
- 모든 테스트 보고서는 작성일 기준 테스트 진행 상황 관련 필요한 정보를 독자에게 제공해야 한다. (테스트 실행 결과가 나오면 그것에 대한 요약도 포함해야 한다.)
- 테스트 모니터링과 제어 작업 산출물은 작업 완료, 리소스 할당과 사용, 공수 등과 같이 프로젝트 관리에서 관심을 가지는 사항에 대해서도 다루어야 한다.
- 5.3 절에서 상세히 다루고 있다.

#### 테스트 분석 작업 산출물
- 이상적으로는 각 테스트 컨디션과 그것이 커버하는 테스트 베이시스 요소와의 양방향 추적성이 성립되어 있어야 한다.
- 탐색적 테스팅에서는 테스트 분석 중 테스트 차터를 생성할 수 있다.
- 테스트 분석에서 테스트 베이시스의 결함을 발견, 보고할 수 있다.

#### 테스트 설계 작업 산출물
- 테스트 분석에서 정의한 테스트 컨디션을 실행할 수 있는 테스트 케이스와 테스트 케이스 세트가 만들어진다.
- 이상적으로는 각각의 테스트 케이스와 그것이 커버하는 테스트 컨디션 간의 양방향 추적성이 성립되어 있어야 한다.
- 결과물
  - 필요한 테스트 데이터의 설계나 식별
  - 테스트 환경 설계
  - 인프라와 도구의 식별

#### 테스트 구현 작업 산출물
- 산출물
  - 테스트 프로시저와 이 프로시저의 배열
  - 테스트 스위트
  - 테스트 실행 일정

- 이상적인 상황에서는 테스트 구현이 끝나면, 테스트 케이스와 테스트 컨디션을 통해 테스트 프로시저와 테스트 베이시스
개별 요소 간의 양방향 추적성을 확인함으로써 테스트 계획에서 정의한 커버리지 조건의 달성 여부를 확인할 수 있다.
- 테스트 구현이 도구를 사용하거나 도구로 생성되는 작업 산출물을 포함하는 경우도 있다.
- 테스트 구현의 결과로 테스트 데이터와 테스트 환경을 구현 및 검증할 수도 있다.
- 테스트 데이터는 테스트 케이스의 입력값과 기대 결과값에 확정값을 할당하는 데 사용한다.
  (해당 값의 사용에 대한 세부적인 지침으로 이렇게 확정된 값은 상위 수준 테스트 케이스를 실행 가능한 하위 수준 테스트 케이스로 변화시킨다.
  테스트 대상의 다른 릴리스에 대해 같은 상위 수준 테스트 케이스를 실행할 경우 다른 테스트 데이터를 사용할 수 있다. 확정된 데이터에 대한 확정 기대 결과값은 테스트 오라클을 통해 식별할 수 있다.)
- 테스트 분석에서 정의한 테스트 컨디션은 테스트 구현 중 추가로 개선할 수 있다.

#### 테스트 실행 작업 산출물
- 산출물
  - 개별 테스트 케이스나 테스트 프로시저의 상태에 대한 문서
  - 결함 보고서
  - 테스팅에 사용한 테스트 항목, 테스트 대상, 테스트 도구, 테스트웨어 등에 대한 문서

- 이상적인 상황에서는, 테스트 실행이 끝나면 연관된 테스트 프로시저와의 양방향 추적성을 활용해서 테스트 베이시스 개별 요소의 상태에 대해 판단하고 보고할 수 있다.
- 커버리지 조건 충족 여부를 검증할 수 있으며, 테스트 결과를 이해관계자가 이해할 수 있는 형태로 보고할 수 있다.

#### 테스트 완료 작업 산출물
- 산출물
  - 테스트 요약 보고서
  - 차후 프로젝트나 반복주기의 개선을 위한 액션 아이템
  - 수정 요청서 혹은 제품 백로그 항목
  - 완성된 테스트웨어 등

---
### 1.4.4 테스트 베이시스와 테스트 작업 산출물 간의 추적성
#### 테스트 작업 산출물과 그 작업 산출물의 명칭은 매우 다양하다.
#### 비록 그렇다하더라도 효과적인 테스트 모니터링과 제어를 구현하기 위해서는 테스트 프로세스 전반에 걸쳐 테스트 베이시스의 개별 요소 및 해당 요소와 연관된 다양한 테스트 작업 산출물 간의 추적성을 확립하고 유지하는 것이 중요하다.
#### 좋은 추적성은 커버리지에 대한 평가를 가능하게 할 뿐만 아니라 아래와 같은 장점도 제공한다.
- 수정으로 인한 영향 평가
- 테스팅에 대한 감시
- IT 통제 조건 충족
- 테스트 베이시스 개별 요소의 상태에 대한 정보를 포함함으로써 테스트 진행 상황 보고서와 테스트 요약 보고서를 좀 더 쉽게 이해할 수 있다.
- 테스팅의 기술적인 내용을 이해관계자가 이해할 수 있는 형태로 전달한다.
- 비즈니스 목표 대비 제품 품질, 프로세스 역량, 프로젝트 진행 상황 등을 평가할 수 있는 정보를 제공한다.

</div>
</details>


<details>
<summary> 1.5 테스팅의 심리학 </summary>
<div>

## 1.5 테스팅의 심리학
### 소프트웨어 테스팅을 포함한 소프트웨어 개발은 사람이 하는 일이다.
### 따라서, 인간 심리학은 소프트웨어 테스팅에 중요한 영향을 미친다.

---
### 1.5.1 인간 심리학과 테스팅
#### 테스터와 테스트 관리자는 결함, 장애, 테스트 결과, 테스트 진행 상황, 리스크 등을 효과적으로 전달하기 위해, 또는 동료와 긍정적인 관계를 구축하기 위해 좋은 대인 관계 기술을 가질 필요가 없다.

#### 의사 소통을 더 잘할 수 있는 방법에 대한 예제
- 다툼 보다는 협력
- 테스팅의 이점을 강조
- 테스트 결과와 기타 발견 사항을 중립적이면서 사실에 기반을 둔 방법으로 전달해야 한다.
- 결함이 발생한 항목을 제작한 사람을 비판해서는 안 된다.
- 객관적이고 사실에 기반을 둔 결함 보고서와 리뷰 결과서를 작성하라
- 상대방이 어떤 느낌을 받을지, 또 해당 정보에 대해 부정적으로 반응하는 이유가 뭔지를 이해하려고 해야 한다.
- 상대방이 전달받을 내용을 이해했는지, 또 반대로 상대방이 하고자 하는 말을 제대로 이해했는지 확인하라.

#### 테스터는 개인의 성향은 최대한 배제하고 이런 목표와 부합하려고 하는 자세가 매우 중요하다.

---
### 1.5.2 테스터와 개발자의 사고방식
#### 테스팅의 목적은 제품에 대한 벨리데이션과 베리피케이션, 릴리스 전 결함 발견 등으로 다양한데, 목적이 다르기 때문에 필요한 사고 방식도 다르다. 이런 사고방식을 적절히 조합해서 사용하면 더 높은 수준의 제품 품질을 달성할 수 있다.

#### 테스터는 호기심, 전문적 비평(professional pessimism) 능력, 비판적 시각, 세밀한 것에 주목하는 태도, 긍정적인 의사소통과 관계 수립에 대한 동기 등의 사고방식을 가지고 있어야 한다. 이 테스터의 사고방식은 테스터가 경험을 쌓아감에 따라 점차 확대되고 성숙해지는 경향을 가지고 있다.

#### 개발자의 사고방식에도 테스터의 사고방식과 같은 요소가 일부 있을 수 있지만, 성공적인 개발자는 해결책을 설계하고 구축하는 데 더 관심을 기울이며 그런 해결책에 무슨 문제가 있는 지에 대해 관심을 가지는 경우는 많지 않다. 또한 확증 편향때문에 자신이 만든 오류에 대해 인지하기 어렵다.

</div>
</details>

</div>
</details>

---
<details>
<summary>
<font size="4em" color="orange">
2장 소프트웨어 개발 수명주기와 테스팅
</font>
</summary>
<div>


<details>
<summary> 2.1 소프트웨어 개발 수명주기 모델 </summary>
<div>

---
## 2.1 소프트웨어 개발 수명주기 모델
### 2.1.1 소프트웨어 개발과 소프트웨어 테스팅
#### 소프트웨어 개발 수명주기 모델을 잘 이해하는 것은 테스터의 중요한 역할이다 !

#### 소프트웨어 개발 수명주기 모델에 적용하기 좋은 테스팅의 특성
- 모든 개발 활동은 그에 상응하는 테스트 활동이 있다.
- 각 테스트 레벨은 그 레벨에 맞는 구체적인 목적을 가진다.
- 주어진 테스트 레벨에 맞는 테스트 분석과 설계는 상응하는 개발 활동이 이루어지고 있는 동안 시작해야 한다.
- 테스터가 요구사항과 설계의 정의와 개선을 위한 대화에 참여하고, 작업 산출물의 초안이 나오는 즉시 리뷰에 참여한다.

#### 시간과 비용을 절약할 수 있다는 테스트 원리에 따라, 테스트 활동은 수명주기 초반에 시작해야 한다.

#### 대표적인 소프트웨어 개발 수명주기 모델을 아래와 같이 분류하고 있다.
- `순차적 개발 모델`
  - 소프트웨어 개발 프로세스를 1차원적 선형의 순자적 활동으로 설명한다. (개발 프로세스의 모든 단계는 이전 단계가 완료될 때 시작되어야 한다.)
  - 완성된 기능 세트를 포함한 소프트웨어를 배포할 수 있지만, 일반적으로 이해관계자와 사용자에게 배포하기까지 몇 개월 또는 몇 년이 걸린다.
  - **폭포수 모델**에서는, 개발 활동이 순차적으로 이루어진다. 이 모델에서의 테스트 활동은 모든 개발 활동을 완료한 후에 이루어진다.
  - 폭포수 모델과는 다르게, V-모델은 테스팅을 초기에 시작하면 좋다는 원리를 토대로 테스트 프로세스를 전반적인 개발 프로세스에 통합한다.
  - **V-모델**은 대응하는 각 개발 단계에 테스트 레벨을 부여함으로써, 조기 테스팅을 좀 더 적극적으로 구현하고 있다.

- `반복적 점진적 개발 모델`
  - 요구사항 정의, 시스템의 설계, 구축, 테스팅을 조각으로 나눠서 진행한다.
  - 소프트웨어 기능은 점진적으로 늘어나게 된다. (이런 증분의 크기는 다양하게 설정할 수 있다.)
  - 기능 증분은 사용자 인터페이스 화면이나 신규 문의 옵션에 생기는 변경 하나만큼 작을 수 있다.
  - **대표적인 예**
  
  | 프로세스명       | 반복주기                                                                             | 기능증분                                        |
  |-------------|----------------------------------------------------------------------------------|---------------------------------------------|
  | 레셔널 통합 프로세스 | 상당히 긴 편(2, 3 개월)                                                                 | 상당히 큼                                       |
  | 스크럼         | 상당히 짧은 편 (몇 시간, 며칠, 또는 몇 주)                                                      | 작음(몇 가지 개선 사항 혹은 2, 3개의 신규 기능)              |
  | 칸반          | 고정된 경우와 않은 경우가 있으며, 각 반복주기는 완료 후 하나의 개선 사항이나 기능을 전달하거나 몇 개의 기능을 묶어 한번에 전달할 수 있음. | -                                           |
  | 나선형         | -                                                                                | 실험적인 증분을 생성 (일부는 차후 개발 과정에서 상당 부분 수정 or 폐기) |

  - 이런 방법을 사용하면 점진적으로 커지는 시스템을 만들 수 있으며, 해당 시스템은 최종 사용자에게 기능별, 반복주기별, 아니면 좀 더 전통적인 주요 릴리스 단위로 릴리스할 수 있다.

---
### 2.1.2 정황에 따른 소프트웨어 개발 수명주기 모델
#### 프로젝트 정황과 제품 특성에 따라 선택하고 적용해야 한다.

#### 프로젝트의 목표, 개발 대상 제품 유형, 비즈니스 특성, 식별된 제품 및 프로젝트 리스크 등을 기반으로 적합한 소프트웨어 개발 모델을 선택할 필요가 있다.

#### 프로젝트 정황에 따라 테스트 레벨과 테스트 활동을 조합하거나 조정해야 할 경우가 존재한다.

#### 소프트웨어 개발 수명주기 모델 자체도 조합할 수 있다.
- 예를들어, 백엔드 시스템과 그것의 통합에 대한 개발과 테스팅에는 V-모델을 사용하고, 프론트엔드 사용자 인터페이스 기능의 개발과 테스트에는 애자일 개발 모델을 사용할 수 있다.

#### 다수의 다양한 오브젝트로 구성된 사물인터넷 시스템에서는 보통 오브젝트 별로 다양한 소프트웨어 개발 수명주기 모델을 적용한다. 

#### 소프트웨어 개발 모델이 프로젝트 및 제품 특성의 맥락에 맞게 조정되어야 하는 이윤는 다음과 같다.
- 시스템의 제품 리스크의 차이 (복잡하거나 간단한 프로젝트)
- 많은 사업부가 프로젝트나 프로그램의 일부일 수 있다. (순차적 및 애자일 개발의 조합)
- 제품의 짧은 출시 기간 (테스트 레벨에서 테스트 유형의 통합 및 테스트 레벨 병합)

</div>
</details>

<details>
<summary> 2.2 테스트 레벨 </summary>
<div>

## 2.2 테스트 레벨
#### 정의: 함께 분류되고 관리되는 테스트 활동의 집합
#### 개별 단위(unit)나 컴포넌트에서부터 완성된 시스템이나 경우에 따라서는 시스템의 시스템까지 해당 개별 레벨의 소프트웨어와 관련해 실행되는 전체 테스트 프로세스의 하나의 사례

#### 테스트 레벨
- 컴포넌트 테스팅
- 통합 테스팅
- 시스템 테스팅
- 인수 테스팅

#### 특성(기준)
- 구체적인 목적
- 테스트 케이스를 도출하기 위해 참고하는 테스트 베이시스
- 테스트 대상 (즉, 테스트 되고 있는 것)
- 일반적인 결함과 장애
- 구체적인 접근법과 역할

---
### 2.2.1 컴포넌트 테스팅
#### 컴포넌트 테스팅의 목적
- 개별적으로 테스팅할 수 있는 컴포넌트에 초점을 맞춘다.
- 목적
  - 리스크 완화
  - 컴포넌트의 기능과 비기능 동작이 설계 및 명세와 일치하는지 여부 판단
  - 컴포넌트 품질 수준에 대한 자신감 획득
  - 컴포넌트에 존재하는 결함 발견
  - 다음 단계로의 결함 전이 방지

#### 경우에 따라, 특히 코드 변경이 지속해서 이루어지는 점진적 반복적 개발 모델(ex, 애자일)에서는 수정으로 인해 기존 컴포넌트가 손상되지 않았다는 확신을 얻는 데 자동 컴포넌트 리그레션 테스트가 중요한 역할을 한다.

#### 컴포넌트 테스팅은 소프트웨어 개발 수명주기 모델과 시스템에 따라 개별적으로 이루어지는 경우가 많으며, 그럴 경우 오브젝트, 서비스 가상화, 하네스, 스텁, 드라이버 등이 필요할 수있다. 

#### 테스트 베이시스
- 산출물
  - 상세 설계
  - 코드
  - 데이터 모델
  - 컴포넌트 명세

#### 테스트 대상
- 대상
  - 컴포넌트, 단위, 모듈
  - 코드 및 데이터 구조
  - 클래스
  - 데이터베이스 모듈

#### 대표적인 결함과 장애
- 결함 및 장애
  - 잘못된 기능
  - 데이터 흐름 문제
  - 잘못된 코드 및 논리

---
### 2.2.2 통합 테스팅
#### 통합 테스팅의 목적
- 컴포넌트나 시스템 간의 상호작용에 초점을 맞춰서 진행한다.
- 목적
  - 리스크 완화
  - 인터페이스와 기능과 비기능 동작이 설계 및 명세와 일치하는지 여부 판단
  - 인터페이스 품질 수준에 대한 자신감 획득
  - 결함 발견
  - 다음 단계로의 결함 전이 방지

#### 컴포넌트 테스팅과 마찬가지로, 자동 통합 리그리션 테스트를 수행하여 수정으로 인해 기존 인터페이스, 컴포넌트 시스템 등이 손상되지 않았다는 확신을 얻는 경우가 있다.

#### `컴포넌트 통합 테스팅`
- 통합된 컴포넌트 간의 상호운용성과 인터페이스에 초점을 맞춘다. 컴포넌트 통합 테스팅은 컴포넌트 테스팅 후 수행하며 자동화하는 경우가 많다.
- 반복적 점진적 개발에서는 컴포넌트 통합 테스트를 지속적으로 통합 프로세스의 일부로 수행한다.

#### `시스템 통합 테스팅`
- 시스템, 패키지, 마이크로 서비스간의 상호운용성과 인터페이스에 초점을 맞춘다.
- 기존 컴포넌트와의 상호운용 혹은 인터페이스를 커버하기도 한다. (이 경우 개발 조직이 외부 인터페이스를 제어하지 않으므로 테스팅에 여러 가지 어려움을 겪을 수 있다.)
- 시스템 테스팅 후 또는 진행중인 시스템 테스팅 활동과 병행해서 수행할 수 있다.

#### 테스트 베이시스 (통합 테스팅)
- 산출물
  - 소프트웨어 및 시스템 설계
  - 시퀀스 다이어그램
  - 인터페이스 및 통신 프로토콜 명세
  - 유스케이스
  - 컴포넌트나 시스템 레벨의 아키텍처
  - 워크플로우
  - 외부 인터페이스 정의서

#### 테스트 대상 (통합 테스팅)
- 대상
  - 서브시스템
  - 데이터베이스
  - 인프라
  - 인터페이스
  - APIs
  - 마이크로서비스

#### 일반적인 결함과 장애 (컴포넌트 테스팅)
- 결함과 장애
  - 잘못된 데이터, 누락된 데이터, 잘못된 데이터 인코딩
  - 잘못된 인터페이스 콜 순서나 타이밍
  - 인터페이스 불일치
  - 컴포넌트 간의 통신 장애
  - 컴포넌트 간의 통신 실패처리 누락 및 오류
  - 컴포넌트 간 주고 받은 데이터의 의미, 단위, 경계에 대한 잘못된 가정

#### 반적인 결함과 장애 (시스템 통합 테스팅)
- 결함과 장애
  - 시스템 간의 일관적이지 않은 메시지 구조
  - 잘못된 데이터, 누락된 데이터, 잘못된 데이터 인코딩
  - 인터페이스 불일치
  - 시스템 간의 통신 장애
  - 시스템 간의 통신 실패 처리 누락 및 오류
  - 시스템 간 주고 받는 데이터의 의미, 단위, 경계에 대한 잘못된 가정
  - 필수 보안 규정 준수 실패

---
### 2.2.3 시스템 테스팅
#### 시스템 테스팅의 목적
- 전체 시스템 또는 제품의 동작이나 능력에 관심을 가지며, 시스템이 수행할 엔드-투-엔드 작업과 
그런 작업을 수행할 때 나타나는 비기능 동작을 고려하는 경우가 많다.
- 목적
  - 리스크 완화
  - 시스템의 기능/비기능 동작이 설계 및 명시된 대로 이루어지는지 검증
  - 완성된 시스템이 기대한 대로 동작하는지 확인
  - 전체 시스템 품질에 대한 자신감 획득
  - 결함 발견
  - 결함이 상위 테스트 레벨이나 생산 단계로의 전이 방지

#### 테스트 베이시스
- 산출물
  - 시스템 및 소프트웨어 요구사항 명세 (기능/비기능)
  - 리스크 분석 보고서
  - 유스케이스
  - 에픽과 사용자 스토리
  - 시스템 동작 모델
  - 상태 다이어그램
  - 시스템 및 사용자 메뉴얼

#### 테스트 대상
- 대상
  - 애플리케이션
  - 하드웨어/소프트웨어 시스템
  - 운영 시스템
  - 테스트 대상 시스템
  - 시스템 설정과 설정 데이터

#### 일반적인 결함과 장애
- 잘못된 연산
- 시스템의 잘못되거나 예상하지 못한 기능/비기능 동작
- 시스템 내 잘못된 제어 및 데이터 흐름
- 앤드-투-앤드 기능 작업 수행 실패
- 시스템 환경에서 시스템의 정상 작동 실패
- 시스템 및 사용자 메뉴얼대로의 시스템 동작 실패

---
### 2.2.4 인수 테스팅
#### 인수테스팅의 목적
- 시스템 테스팅과 마찬가지로 인수 테스팅도 전체 시스템 또는 제품의 동작이나 능력에 초점을 두고 진행하는 경우가 많다.
- 목적
  - 전체 시스템의 품질에 대한 자신감 획득
  - 완성된 시스템이 기대한 대로 동작하는지 확인
  - 시스템의 기능/비기능 동작이 명세대로 동작하는지 검증

#### 인수테스팅 결과로 시스템을 배포하거나 고객이 사용할 준비가 어느정도 되었는지 평가할 수 있는 정보를 만들 수 있다.
#### 인수 테스팅 중 결함이 발견될 수 있지만, 결함 발견 목적이 아닌 경우가 많으며, 인수 테스팅에서 결함이 발견되면 심각한 프로젝트 리스크로 인식하는 경우가 많다.
#### 인수 테스팅으로 법적 규정 요구사항이나 표준을 만족할 수 있다.

#### 대표적인 유형
- 사용자 인수 테스팅
- 운영 인수 테스팅
- 계약 및 인수 테스팅
- 알파 및 베타 테스팅

---
#### 1. 사용자 인수 테스팅
- 정의: 일반적으로 실제 또는 시뮬레이션된 운영 환경에서 예정된 사용자가 사용하기에 적합한지에 대하여 초점을 둔다.
- 목적: 사용자가 요구사항을 충족하면서 최소한의 어려움, 비용, 리스크 등으로 비즈니스 프로세스를 수행할 수 있다는 자신감을 획득하는 것이다.

#### 2. 운영 인수 테스팅
- 정의: 운영자 또는 시스템 관리 직원에 의해 수행되는 시스템 인수 테스팅은 생산 환경에서 이루어지는 경우가 많다.
- 포함되는 것들
  - 백업 및 복원 테스팅
  - 설치, 삭제, 업그레이드
  - 사용자 관리
  - 유지보수 작업
  - 데이터 로딩 및 이관 작업
  - 보안 취약점 확인
  - 성능 테스팅

#### 3. 계약 및 규제 인수 테스팅
- 정의: 주문 개발 소프트웨어의 생산을 위한 계약서에 명시된 인수 조건을 가지고 수행한다. (독립적인 테스터가 수행하는 경우가 많다.)
- 목적: 계약이나 규제 준수에 대한 자신감 획득

#### 4. 알파 및 베타 테스팅
- 알파 테스팅: 개발 조직의 현장에서 개발팀이 아닌 신규 혹은 기존 고객이나 운영자, 독립적 테스트팀이 수행한다.
- 베타 테스팅: 신규 혹은 기존 고객이나 운영자가 자신의 환경에서 수행한다.
- 목적
  - 신규 혹은 기존 고객이나 운영자가 시스템을 일반적인 조건과 운영 환경에서 사용해 자신의 목적을 최소한의 어려움, 비용, 리스크 등으로 완수할 수 있다는 자신감을 획득하는 것이다. 
  - 시스템을 사용할 조건 및 환경과 관련된 결함의 발견


#### 데이터 베이시스
- 산출물
  - 비즈니스 프로세스
  - 사용자 또는 비즈니스 요구사항
  - 규제, 법적 계약, 표준
  - 유스케이스 및 사용자 스토리
  - 시스템 요구사항
  - 시스템 및 사용자 문서
  - 설치 절차
  - 리스크 분석 보고서

- 테스트 케이스를 도출하기 위한 테스트 베이시스의 산출물
  - 백업 및 복원 절차
  - 긴급 복구 절차
  - 비기능 요구사항
  - 운영 문서
  - 배포 및 설치 지침
  - 성능 목표
  - 데이터베이스 패키지
  - 보안 표준 또는 규정

#### 일반적인 테스트 대상
- 테스트 대상 시스템
- 시스템 설정과 설정 데이터
- 완전히 통합된 시스템의 비즈니스 프로세스
- 복원 시스템이나 비즈니스 연속성 및 긴급 복구 테스팅을 위한 한 사이트
- 운영 및 유지보수 프로세스
- 양식
- 보고서
- 기존 및 전환된 생산 데이터

#### 일반적인 결함과 장애
- 비즈니스나 사용자 요구사항을 충족하지 못하는 시스템 워크플로우
- 잘못 구현된 비즈니스 규칙
- 계약 혹은 규제 요구사항을 충족하지 못하는 시스템
- 보안 취약성, 많은 부하가 걸렸을 때, 성능 효율성 저하, 지원 대상 플랫폼상에서의 잘못된 운영 등과 같은 비기능 장애

#### 인수 테스팅은 순차적 개발 수명주기의 마지막 테스트 레벨로 여겨지는 경우가 많지만, 다음과 같이 다른 시점에서 이루어지는 경우도 있다.
- 상용 소프트웨어 제품에 대한 인수테스팅은 그것이 설치되거나 통합될 때 이루어진다.
- 신규 기능 개선 사항에 대한 인수 테스팅은 시스템 테스팅 전에 이루어질 수 있다.

</div>
</details>


<details>
<summary> 2.3 테스트 유형 </summary>
<div>

## 2.3 테스트 유형
#### 정의: 특정 테스트 목적을 위해 소프트웨어 시스템이나 시스템의 일부 특성을 테스트하는 활동의 집합
#### 목적
- 완전성, 정확성, 적합성 등과 같은 기능 품질 특성 평가
- 신뢰성, 성능 효율성, 보안성, 호환성, 사용성 등과 같은 비기능 품질 특성 평가
- 컴포넌트나 시스템의 아키텍쳐 및 구조가 정확하고 완전하며 명시된 것과 일치하는지 평가
- 수정의 효과 평가

---
### 2.3.1 기능 테스트
#### 시스템이 수행해야 하는 기능을 평가하기 위한 테스트를 포함한다.
#### 기능이란 ? 시스템이 해야하는 그 "무엇" !
- 모든 테스트 레벨에서 수행해야 하지만, 각 레벨에서의 관심사항이 다를 수 있다.
- 소프트웨어 동작을 보기 때문에 컴포넌트나 시스템의 기능에 대한 테스트 컨디션과 테스트 케이스 도출을 위해 블랙박스 기법을 활용할 수 있다.
- 얼마나 철저하게 수행됐는지 기능 커버리지를 통해 측정할 수 있다.

#### 기능 커버리지 ? 어떤 기능이 테스트에 의해 어느 정도 실행됐는지를 뜻하며, 커버되고 있는 요소 유형에 대한 백분율로 표기된다.

---
### 2.3.2 비기능 테스트
#### 사용성, 성능 효율성 또는 보안성과 같은 시스템의 특성을 평가!!
#### 비기능 테스트란 ? 시스템이 "얼마나 잘" 동작하는지에 대한 테스팅을 말한다.
- 모든 테스트 레벨에서 수행할 수 있고, 수행해야 한다.
- 가능한 초반에 수행하는 것이 좋다.
- 블랙박스 기법은 비기능 테스트를 위한 테스트 컨디션과 테스트 케이스를 도출하는 데 사용할 수 있다.
- 비기능 커버리지를 사용해서 측정할 수 있다.

#### 비기능 커버리지 ? 특정 비기능 요소가 테스트로 어느 정도 실현됐는지 말해주며 커버하고 있는 요소 유형에 대한 백분율로 표기된다.

---
### 2.3.3 화이트박스 테스팅
#### 시스템의 내부 구조나 구현을 기반으로 테스트를 도출한다. (내부 구조: 코드, 아키텍쳐, 워크플로우, 데이터플로우 등)
#### 화이트박스 테스팅이 얼마나 철저하게 이루어졌는지는 구조 커버리지를 통해 측정할 수 있다.
#### 구조 커버리지란 ? 특정 구조 요소가 테스트에 의해 어느 정도 실행됐는지를 말하며, 커버하고 있는 요소 유형에 대한 백분율로 표기한다.

#### 컴포넌트 테스팅 레벨에서 얘기하는 코드 커버리지 ? 컴포넌트 코드 중 테스트된 비율
- 컴포넌트의 실행 가능한 구문 중 테스트된 비율이나 결정 결과값 중 테스트된 비율 등 코드의 여러 가지 측면으로 측정될 수있다.
- 이와 같은 유형의 커버리지를 합쳐서 코드 커버리지라고 한다.
- 컴포넌트 간의 인터페이스와 같은 시스템의 아키텍처를 기반으로 화이트박스 테스팅을 수행할 수 있다.
- 구조 커버리지를 인터페이스 중 테스트된 비율의 측면에서 측정할 수 있다.


---
### 2.3.4 변경 관련 테스팅
#### 시스템이 변경되면, 해당 변경이 결함을 제대로 수정했는지, 기능을 올바르게 구현했는지 또 예상하지 못한 부작용이 발생하지 않았는지 확인하기 위한 테스팅을 수행할 필요가 있다.

#### 확인 테스팅
- 결함 수정에 필요한 변경을 커버하기 위해 소프트웨어를 대상으로 새로운 테스트를 수행할 수도 있다.
- 최소한 결함으로 발생했던 장애의 재현 절차를 새로운 소프트웨어 버전에서 실행해볼 필요가 있다.
- 확인 테스팅의 목적은 원래 제대로 결함을 수행했는지 확인하는 것이다.

#### 리그레션 테스팅
- 변경에는 운영 시스템이나 데이터베이스 관리 시스템의 신규 버전 등과 같은 환경에 대한 변경도 포함한다.
- 이런 의도하지 않은 부작용을 리그레션이라 부른다.
- 정의: 이런 의도하지 않은 부작용을 발견하기 위해 수행하는 것이다.

#### 확인 테스팅 & 리그레션 테스팅은 모든 테스트 레벨에서 수행 가능하다.

#### 반복적 점진적 개발 수명주기(ex, 애자일)에서는 신규기능, 기존 기능에 대한 변경, 코드 리팩토링 때문에 코드에 잦은 변경이 가해지고 결국 변경 관련 테스팅이 필요하다.
#### 시스템이 진화하는 특성 때문에 확인 및 리그레션 테스팅이 중요한데, 개별 오브젝트가 자주 업데이트되거나 교체되는 사물인터넷 시스템에서는 더욱 중요하다.

#### 리그레션 테스트 스위트 ? 여러번 반복 수행되며 대개는 서서히 변화하기 때문에 리그레션 테스팅은 자동화에 적합하다. 이런 테스트의 자동화는 프로젝트 초반에 시작해야 한다.

---
### 2.3.5 테스트 유형과 테스트 레벨 (예제)

| 구분         | 기능 테스트                                                    | 비기능 테스트                                                           | 화이트박스 테스트                                                          |변경 관련 테스트|
|------------|-----------------------------------------------------------|-------------------------------------------------------------------|--------------------------------------------------------------------|-|
| 컴포넌트 테스팅   | 컴포넌트가 복잡한 이자 계산을 어떻게 하는지를 기반으로 설계                         | 복잡한 전체 이자 계산을 수행하기 필요한 CPU 사이클(cycle) 횟수를 평가하기 위해 성능 테스트 설계       | 금융 계산을 수행하는 모든 컴포넌트에 대한 완벽한 구문 및 결정 커버리지를 달성하기 위한 테스트 설계           |각 컴포넌트를 위한 자동 리그레션 테스트가 구축되고 지속적인 통합 프레임워크에 포함|
|컴포넌트 통합 테스팅|                                                           |                                                                   |브라우저 인터페이스의 각 화면이 다음 화면과 비즈니스 로직을 기반으로 데이터를 어떻게 전달하는지 확인하기 위한 테스트 설계|인터페이스 관련 결함 수정이 코드 저장소에 체크인(check-in)됐을 때 해당 수정을 확인하기 위한 테스트 설계|
| 시스템 테스팅    | 사용자 인터페이스에서 포착하는 계정정보가 어떻게 비즈니스 로직으로 전달되는지를 기반으로 설계       | 보이는 화면이 모든 지원 대상 브라우저와 모바일 기기에서 제대로 동작하는지 확인하기 위한 이식성 테스트 설계      | 신용 한도 신청 도중 순차적으로 거치게 되는 웹페이지를 커버하기 위한 테스트 설계                                                                   |특정 워크플로우에 속하는 화면 중 하나만 변경되더라도 해당 워크플로우에 대한 모든 테스트 실행|
| 시스템 통합 테스팅 | 시스템이 외부 마이크로서비스를 사용해서 계좌 소유주의 신용 점수를 확인하는 방법을 기반으로 테스트 설계 | 신용 점수 마이크로서비스가 응답하지 않을 때 시스템의 강건성(robustness)을 평가하기 위한 신뢰성 테스트 설계 | 신용 점수 마이크로서비스로 보내는 모든 조회(inquiry) 유형을 실행하기 위한 테스트 설계 |신용 점수 마이크로서비스에 대한 지속적인 개발의 일환으로 해당 마이크로서비스와 상호작용하는 애플리케이션에 대한 테스트를 매일 재실행|
| 인수 테스팅     | 은행이 신용 한도를 승인하거나 거절하는 방법을 기반으로 테스트 설계                     | 은행 신용 처리 인터페이스에 장애인의 접근성을 평가하는 사용성 테스트 설계                         | 은행 간 이체에서 지원하는 모든 금융 데이터 파일 구조와 값 범위를 커버하기 위한 테스트 설계|인수 테스팅에서 발견된 결함이 수정되면 기존에 불합격했던 모든 테스트를 재실행|


#### 위에서 모든 레벨에 모든 테스트 유형을 적용한 예제를 제공했지만, 모든 소프트웨어가 모든 레벨에 모든 테스트 유형을 적용해야 하는 것은 아니다.
#### 그러나 각 레벨에 가능한 테스트 유형을 수행하는 것이 중요하며, 특히 해당 테스트 유형이 처음으로 발생하는 첫 레벨에서 수행하는 것이 중요하다.

</div>
</details>

<details>
<summary> 2.4 유지보수 테스팅 </summary>
<div>

## 2.4 유지보수 테스팅
#### 유지보수의 일환으로 변경이 이루어지게 되면, 변경의 성공 여부를 평가하고 시스템의 변경되지 않은 부분에는 부작용(ex, 리그레션)의 발생 여부를 확인하기 위해 유지보수 테스팅을 수행해야 한다.

#### 유지보수 릴리스는 그것의 범위에 따라 다양한 테스트 유형을 활용한 복수의 테스트 레벨에서의 유지보수 테스팅이 필요할 수 있다.

### 유지보수 테스팅의 범위는 다음과 같은 영향을 받는다.
- 변경의 리스크 수준
- 기존 시스템의 규모
- 변경의 규모

---
### 2.4.1 유지보수가 필요한 상황
- 개선을 위한 변경, 계획된 확장, 수정 혹은 긴급 변경, 운영 환경 변경, 상용 소프트웨어 업그레이드, 결함 및 취약성을 위한 패치 등
- 이관을 위한 변경, 유지보수하고 있는 시스템에 이관하는 다른 애플리케이션의 데이터를 위한 데이터 전환 테스트 등
- 단종
- 장시간의 보관이 필요한 경우

#### 사물 인터넷 시스템에서는 유지보수 테스팅이 완전히 새롭거나 개선된 사물을 전체 시스템에 추가하는 것을 계기로 발생할 수 있다.
#### 이러한 시스템에 대한 유지보수 테스팅은 다양한 레벨에서의 통합 테스팅과 보안 측면, 특히 개인 정보와 관련된 측면에 집중하게 된다.

---
### 2.4.2 유지보수를 위한 영향도 분석
#### 영향도 분석은 유지보수 릴리스에 포함된 변경을 평가해서, 의도한 결과뿐만 아니라 변경으로 인해 발생할 수 있는 예견된 부작용을 식별하고, 변경의 양향을 받는 시스템 영역을 식별하기 위해 실시한다.
#### 영향도 분석은 변경이 기존 테스트에 미치는 영향을 식별하기 위해 사용할 수 있다. 부작용과 영향 받은 시스템 영역에 대해서는, 필요한 경우 변경의 영향을 받는 기존 테스트를 업데이트해서 리그레션 테스트를 수행할 필요가 있다.

#### 영향도 분석이 어려운 경우
- 명세가 너무 오래됐거나 없는 경우
- 테스트 케이스가 문서화되어 있지 않거나 너무 오래된 경우
- 테스트와 테스트 베이시스 간 양방향 추적성이 유지되지 않은 경우
- 도구 활용이 적거나 없는 경우
- 연관된 인원이 도메인이나 시스템 지식을 가지고 있지 않은 경우
- 소프트웨어의 개발 중 유지보수성에 충분히 신경을 쓰지 못한 경우

</div>
</details>

</div>
</details>

---

<details>
<summary>
<font size="4em" color="yellow">
3장 정적 테스팅
</font>
</summary>
<div>

<details>
<summary> 3.1 정적 테스팅 기초 </summary>
<div>

## 3.1 정적 테스팅 기초
#### 작업 산출물을 수동으로 검사하거나 코드나 다른 작업 산출물을 도구를 기반으로 평가하는 방법에 의존한다.
#### 정적분석은 안전 최우선 컴퓨터 시스템에서 중요하지만 다른 영역에서도 점차 그 중요성이 일반화되고 있다.

---
### 3.1.1 정적 테스팅으로 검토할 수 있는 작업물
#### 대부분의 작업 산출물은 정적 테스팅으로 검사할 수 있다.
- 비즈니스 요구사항, 기능 요구사항, 보안 요구사항과 같은 명세
- 에픽, 사용자 스토리, 인수 기준
- 아키텍처 및 설계 명세
- 코드
- 테스트 계획, 테스트 케이스, 테스트 프로시저, 자동화 테스트 스크립트와 같은 테스트웨어
- 사용자 가이드
- 웹 페이지
- 계약, 프로젝트 계획, 일정, 예산 기획
- 형상 및 인프라 셋업
- 액티비티 다이어그램과 같은 모델 기반 테스팅에 사용되는 모델

#### 정적 분석은 적절한 정적 분석 도구가 존재하는 공식 구조를 사용하는 작업 산출물에 효율적으로 사용할 수 있다.
#### 정적 분석은 요구사항과 같은 자연어로 작업된 작업 산출물을 평가하는 도구로 적용될 수도 있다.


---
### 3.1.2 정적 테스팅의 효과
#### 정적 테스팅을 소프트웨어 개발 수명주기 초반에 적용하면 동적 테스팅을 실행하기 전 결함의 조기 발견을 가능하게 한다.
#### 정적 테스팅 기법을 사용해 결함을 발견하고 바로 수정하는 것이 동적 테스팅으로 결함을 발견하고 수정하는 것에 비해 적은 비용이 드는 경우가 대부분이다.
#### 그 외 효과
- 동적 테스트 실행 전에 보다 효율적으로 결함을 발견하고 수정
- 동적 테스팅으로 발견이 쉽지 않은 결함 식별
- 요구사항 불일치, 애매 모호함 등을 식별해서 설계나 코딩의 결함 예방
- 개발 생산성 향상
- 개발 비용 및 기간 단축
- 테스팅 비용 및 기간 단축
- 수명주기 후반 또는 출시 후 운영 과정에서 발견되는 장애 감소로 소프트웨어 수명주기 전반에 걸치 총 품질 비용 감소
- 리뷰에 참여하는 팀원 간의 의사소통 개선

---
### 3.1.3 정적 테스팅과 동적 테스팅의 차이
#### 정적 테스팅과 동적 테스팅은 발견하는 유형의 결함이 서로 달라 상호 보완적이다.
#### 정적 테스팅
- 소프트웨어를 실행해 결함으로 발생하는 장애를 찾아내기보다는 작업 산출물에서 직접 결함을 발견한다는 것이다.
- 작업 산출물의 일관성과 내부 품질을 향상하기 위해 사용한다.

#### 동적 테스팅
- 일반적으로 외부에 보이는 동작에 초점을 맞추고 있다.
- 소프트웨어를 실행해 발생하는 장애를 찾아내는 테스트이다.

#### 동적 테스팅과 비교해 정적 테스팅으로 발견하기 쉽고 비용도 적게 들어가는 일반적인 결함 유형
- 요구사항 결함
- 설계 결함
- 코딩 결함
- 표준과의 차이
- 잘못된 인터페이스 명세
- 보안 취약점
- 테스트 베이시스 추적성이나 불충분한 커버리지 또는 부정확성

</div>
</details>

<details>
<summary> 3.2 리뷰 프로세스 </summary>
<div>

## 3.2 리뷰 프로세스
#### 리뷰 유형은 공식 리뷰와 비공식 리뷰까지 다양하다.

#### 비공식 리뷰의 특징
- 정의된 프로세스를 따르지 않고, 리뷰 결과를 공식적으로 문서화하여 제공하지 않는다는 점이다.

#### 공식 리뷰의 특징
- 팀 참여, 문서화된 리뷰 결과, 문서화된 리뷰 진행 절차 등 

#### 리뷰 프로세스 형식 
- 소프트웨어 개발 수명주기 모델, 개발 프로세스의 성숙도, 리뷰 대상 작업 산출물의 복잡도, 다양한 법적 또는 규정 요구사항이나 감사 추정의 필요성과 같은 요소와 관련이 있다.


---
### 3.2.1 작업 산출물 리뷰 프로세스
### **계획**
- 리뷰 목적, 리뷰할 문서가 전체인지 특정 부분인지, 평가할 품질 특성 등을 포함하는 범위의 정의
- 노력과 기간 추정
- 리뷰 유형에 따라 결정되는 역할, 활동, 체크리스트와 같은 리뷰 특성의 식별
- 리뷰에 참석할 인원을 선정하고 역할 할당
- 인스펙션과 같은 공식적인 리뷰의 경우에는 시작 및 종료 조건 정의
- (공식 리뷰의 경우) 시작 조건이 충족되는지 확인

### **리뷰 착수**
- 작업 산출물과 이슈 기록 양식, 체크리스트, 관련된 작업 산출물과 같은 기타 자료 배포
- 참가자에게 범위, 목적, 프로세스, 역할, 작업 산출물을 설명
- 참가자가 리뷰에 대해 가질 수 있는 여러 질문에 답변

### **개별 리뷰**
- 작업 산출물 전체 혹은 부분 리뷰
- 잠재 결함, 권고사항, 질문 기록

### **이슈 논의 및 분석**
- 식별한 잠재 결함 전달
- 잠재 결함 분석 및 담당자 및 상태 할당
- 품질 특성 평가 및 문서화
- 종료 조건을 기준으로 리뷰 결과를 평가하여 리뷰 결과 결정

### **수정 및 보고**
- 작업 산출물에 대한 수정을 요하는 잠재 결함에 대한 결함 보고서 작성
- 리뷰한 작업 산출물에서 발견한 결함 수정
- 결함 정보를 적절한 사람이나 팀과 공유
- 필요한 경우 주석 작성자의 동의를 포함해 업데이트된 결함 상태 기록
- 메트릭 수집 (공식적인 리뷰 유형인 경우)
- 종료 조건의 충족여부 확인 (공식 리뷰 유형인 경우)
- 종료 조건이 충족되면 해당 작업 산출물 인수


---
### 3.2.2 공식 리뷰에서의 역할과 책임
### **저자**
- 리뷰 대상 작업 산출물 작성
- 리뷰 대상 작업 산출물 결함 수정

### **관리자**
- 리뷰 계획 담당
- 리뷰 실행 결정
- 인력, 예산, 시간 할당
- 진행 비용 대비 효과 모니터링
- 결과가 만족스럽지 않은 경우 제어 결정 실행

### **촉진자(중재자)**
- 리뷰 회의 진행 시 효과적 회의 진행 보장
- 필요한 경우 다양한 관점들에 대한 중재
- 많은 경우 리뷰의 성공 여부에 결정적인 역할을 하는 사람

### **리뷰 리더**
- 전반적으로 리뷰에 대한 책임을 지는 사람
- 참여자를 결정하고 언제 어디서 진행할지 결정

### **검토자**
- 해당 주제에 대한 전문가, 프로젝트 참여 인원, 작업 산출물에 관심이 있는 이해관계자나 특정 기술 혹은 비즈니스 배경을 가진 사람 등
- 리뷰 대상 작업 산출물의 잠재적 결함 식별
- 다양한 관점을 대표할 수 있음

### **서기**
- 개별 리뷰 활동에서 발견한 잠재 결함 수집
- 리뷰 회의가 진행되는 경우 새로운 잠재 결함, 쟁점, 결정 사항 기록

#### 리뷰 유형에 따라 한 사람이 두 개 이상의 역할을 수행할 수 있으며, 각 역할과 관련된 활동 역시 리뷰 유형에 따라 달라질 수 있다.
#### 리뷰 프로세스를 지원하는 도구, 특히 결함, 쟁점 및 의사 결정의 기록을 지원하는 도구로 인해 서기가 필요하지 않은 경우가 많다.


---
### 3.2.3 리뷰 유형
#### 리뷰를 다양한 목적으로 활용할 수 있지만, 주된 목적 중 하나는 결함 발견이다.
#### 모든 리뷰 유형은 결함 발견에 도움이 될 수 있으며, 프로젝트 요구사항, 가용 자원, 제품 유형과 리스크, 비즈니스 도메인, 조직의 문화 등에 따라 적절한 리뷰 유형을 선택해야 한다.
#### 리뷰에서 발견되는 결함 유형은 특히 리뷰 중인 작업 산출물에 따라 다르다. 리뷰는 다양한 특성에 따라 분류될 수 있으며, 아래에 나오는 4가지 리뷰 유형과 각각의 특성을 나열한다.

### 비공식 리뷰
- ex) 버디 체크, 페어링, 짝 리뷰
- 주요 목적: 잠재적 결함 발견
- 기타 목적: 새로운 아이디어나 해결책 도출, 소소한 문제의 빠른 해결
- 공식 프로세스를 기반으로 하지 않음
- 리뷰 회의를 진행하지 않을 수 있음
- 저자의 동료 또는 다른 사람이 수행할 수 있음
- 결과는 문서로 기록할 수 있음
- 검토자에 따라 성과가 달라짐
- 체크리스트 사용 여부는 상황에 맞게 판단
- 애자일 개발에서 매우 일반적으로 사용됨

### 워크쓰루
- 주요 목적: 결함 발견, 소프트웨어 제품 개선, 다른 구현 방법 고려, 표준이나 규정 준수 평가
- 기타 목적: 다양한 기술이나 스타일에 대한 아이디어 교환, 참여자 교육, 합의 도출
- 리뷰 회의 전 개별 준비는 필요에 따라 수행
- 리뷰회의는 일반적으로 작업 산출물의 저자가 주도
- 서기 참여 필수
- 체크리스트 사용 여부는 상황에 맞게 판단
- 시나리오, 드라이 런, 시뮬레이션의 형태로 수행할 수 있음
- 잠재 결함 로그와 리뷰 보고서 작성
- 실무에서는 비공식적인 형식에서 매우 공식적인 형식까지 다양할 수 잇음

### 기술 리뷰
- 주요 목적: 합의 도출, 잠재적 결함 발견
- 기타 목적: 작업 산출물의 품질 평가 및 자신감 획득, 새로운 아이디어 도출, 저자가 미래의 작업 산출물을 개선하도록 지원하고 동기를 부여, 다른 구현 방법 고려
- 검토자는 저자의 기술 동료이면서, 동일 분야 또는 다른 분야의 기술 전문가여야 함
- 리뷰 회의 전 개별 준비 필요
- 리뷰회의는 선택사항이며, 이상적으로는 훈련된 촉진자가 주도
- 서기는 반드시 있어야 하며, 이상적으로는 저자가 아닌 사람이 수행
- 체크리스트 사용 여부는 상황에 맞게 판단
- 잠재 결함 로그와 리뷰 보고서 작성

### 인스펙션
- 주요 목적: 잠재적 결함 발견, 작업 산출물의 품질 평가 및 자신감 획득, 저자 학습과 근본 원인 분석을 통한 유사 결함의 발생 예방
- 기타 목적: 저자가 앞으로의 작업 산출물과 소프트웨어 개발 프로세스를 개선하고 합의를 이끌어 내도록 동기를 부여
- 규칙 및 체크리스트를 기반으로 공식 문서 산출물을 작성하는 정의된 프로세스를 수행
- 3.2.2 절에서 필수로 지정한 바와 같이 명확하게 정의된 역할 참여, 낭독자의 참여 가능
- 리뷰 회의 전 개별 준비 필요
- 검토자는 저자의 동료 또는 작업 산출물과 연관된 분야의 전문가
- 명시된 시작 및 종료 조건을 사용
- 서기 참여 필수
- 리뷰 회의는 훈련받은 촉진자(저자x)가 주도
- 저자는 리뷰 리더, 글을 읽는 사람 또는 서기가 될 수 없음
- 잠재적인 결함 로그 및 리뷰 보고서 작성
- 인스펙션 프로세스 포함 전체 소프트웨어 개발 프로세스를 개선하기 위해 메트릭을 수집하고 사용

---
### 3.2.4 리뷰 기법 적용

### 애드혹
- 검토자에게 리뷰 수행 방법에 대한 안내가 거의 또는 전혀 제공되지 않는다.
- 검토자는 대부분의 작업 산출물을 순차적으로 읽으면서 이슈를 식별하고 기록한다.
- 특별한 준비없이 일반적으로 사용되는 기법
- 검토자의 능력에 크게 의존하며, 여러 검토자가 동일한 문제를 보고할 수 있다.

### 체크리스트 기반
- 체계적인 기법으로, 검토자는 리뷰 시작 지점에 배포된 체크리스트를 기반으로 이슈를 식별한다.
- 체크리스트는 잠재 결함을 식별하기 위해 경험에서 도출한 일련의 질문으로 구성된다.
- 체크리스트는 리뷰 대상 작업 산출물 유형별로 작성해야 하며 이전 리뷰에서 누락된 이슈 유형을 다루기 위해 주기적으로 개선할 필요가 있다.
- 장점: 일반적인 결함 유형에 대한 체계적인 커버리지를 갖는다는 점이다.

### 시나리오 및 드라이 런
- 검토자는 작업 산출물을 어떻게 검토할지에 대한 구조화된 지침을 제공받는다.
- 작업 산출물의 예상되는 용도를 기반으로 작업 산출물에 대해 "드라이런"을 수행할 수 있도록 검토자를 지원한다.
- 시나리오는 검토자에게 단순한 체크리스트 항목보다 특정 결함 유형을 식별하는 방법에 대한 좀 더 나은 지침을 제공한다.
- 체크리스트 기반 리뷰와 마찬가지로, 다른 결함 유형을 발견하기 위해 검토자는 기록된 시나리오에만 너무 얽매이지 않아야 한다.

### 관점 기반
- 역할 기반 리뷰와 마찬가지로 검토자가 개별 리뷰 중 다양한 이해관계자의 관점을 사용하게 된다.
- 검토자가 리뷰 대상 작업 산출물로부터 이해관계자의 관점을 기반으로 하는 산출물을 작성해야한다. 예를 들면, 테스터가 필요한 모든 정보가 존재하는지 확인하기 위해 요구사항 명세에 대한 관점 기반 읽기를 수행하면서 인수 테스트 초안을 작성하는 것을 시도할 수 있다.
- 체크리스트도 활용한다.
- 실증적인 연구에 의하면, 관점 기반 읽기가 요구사항 및 기술 작업 산출물에 대한 리뷰에 가장 효과적인 기법이다.
- 주요 성공 요인은 리스크를 기반으로 다양한 이해관계자의 관점을 적절하게 포함시키고 평가하는 것이다.

### 역할 기반
- 검토자가 작업 산출물을 개별 이해관계자 역할의 관점에서 평가하는 기법이다.
- 특정 최종 사용자 유형과 조직 내 특정 역할이 있다.
- 역할이 비슷하기 때문에 같은 원칙이 관점 기반 읽기에도 적용된다.

---
### 3.2.5 리뷰의 성공 요소
#### 성공적인 리뷰를 위해서는 적절한 리뷰 유형과 기법을 고려해야 한다.

### 조직 차원의 성공 요인
- 각 리뷰는 목적이 있어야 한다. 목적은 리뷰 계획 시 정의하며, 측정 가능한 종료 조건으로 사용된다.
- 목적을 달성하기에 적합하고, 소프트웨어 작업 산출물 및 참여자 유형수준에 맞는 리뷰 유형을 적용해야 한다.
- 체크리스트 기반 및 역할 기반 리뷰와 같이 사용하는 모든 리뷰 기법은 리뷰 대상 작업 산출물의 결함을 효과적으로 식별하기에 적합해야 한다.
- 체크리스트는 주요 리스크 식별을 위해 작성해야 하며, 가장 최신의 정보를 반영해야 한다.
- 규모가 큰 문서는 작은 단위로 작성하고, 리뷰를 수행해 저자에게 결함에 대한 피드백을 조기 and 빈번하게 제공함으로써 품질 관리를 수행한다.
- 참여자는 충분한 준비 시간을 갖는다.
- 충분한 여유를 가지고 리뷰 일정을 수립한다.
- 경영진은 리뷰 프로세스를 지원한다.
- 리뷰는 기업의 품질 및 테스트 정책에 통합된다.

### 사람과 관련한 성공 요인
- 테스터는 리뷰에 기여하는 중요한 검토자로 간주된다.
- 테스터는 작업 산출물의 학습을 통해 좀 더 효과적인 테스트를 준비하고 조기에 테스트 준비를 할 수 있게 된다.
- 참여자는 세부사항에 충분한 시간과 주의를 기울여야 한다.
- 작은 단위로 리뷰를 진행해 개별 리뷰나 리뷰 회의 중에 검토자가 집중력을 잃지 않도록해야 한다.
- 식별된 결함은 승인하고 평가하고, 객관적으로 처리해야 한다.
- 리뷰 회의를 잘 관리해 참여자가 리뷰에 참여한 시간이 가치 있다고 인식하게 해야 한다.
- 리뷰는 모든 참여자가 서로 신뢰하는 분위기에서 진행해야 한다.
- 참여자는 지루함, 분노 또는 다른 참여자에 대한 적대감을 나타낼 수 있는 신체 언어 및 행동을 피해야 한다.
- 적절한 교육을 제공한다.
- 학습 및 프로세스 개선에 대한 조직 문화를 촉진해야 한다.

</div>
</details>

</div>
</details>


---
<details>
<summary>
<font size="4em" color="green">
4장 테스트 기법
</font>
</summary>
<div>


<details>
<summary> 4.1 테스트 기법의 종류 </summary>
<div>

## 4.1 테스트 기법의 종류
#### 테스트 기법의 목적은 테스트 컨디션, 테스트 케이스, 테스트 데이터 식별을 지원하는 것이다.
#### 관련 요소
- 컴포넌트나 시스템 복잡도
- 규제 기준
- 고객 또는 계약 요구사항
- 리스크 수준과 유형
- 사용 가능한 문서
- 테스터의 지식과 역량
- 사용 가능한 도구
- 시간과 예산
- 소프트웨어 개발 수명주기 모델
- 컴포넌트나 시스템에서 예상되는 결함 유형

#### 테스트 분석, 테스트 설계, 테스트 구현 활동에서 테스트 기법의 사용은 매우 비공식적인 형식부터 매우 공식적인 형식까지 다양할 수 있다. 
#### 적절한 수준의 공식성은 테스트 및 개발 프로세스의 성숙도, 시간적인 제한, 안전 또는 규정 요구사항, 관련된 사람들의 지식과 역량, 준수해야 하는 소프트웨어 개발 수명주기 모델을 포함하는 테스팅의 정황에 따라 결정된다.

---
### 4.1.1 테스트 기법의 종류와 특성
### `블랙박스 테스트 기법`

### 정의
#### 1. 적절한 테스트 베이시스에 대한 분석을 기반으로 한다.
#### 2. 이 기법은 기능 테스팅과 비기능 테스팅 모두에 적용할 수 있다. 블랙박스 기법은 테스트 대상의 내부 구조를 고려하지 않고, 입력과 출력에 집중한다.

### 특징
#### 1. 테스트 컨디션, 테스트 케이스, 테스트 데이터는 소프트웨어 요구사항, 명세서, 유스케이스, 사용자 스토리와 같은 테스트 베이시스로부터 도출된다.
#### 2. 테스트 케이스는 요구사항과 요구사항 구현 결과물 간 차이와 편차를 식별하는 데 사용한다.
#### 3. 커버리지는 테스트 베이시스에서 테스트된 항목과 테스트 베이시스에 적용한 기법을 기반으로 측정한다.



### `화이트박스 테스트 기법`

### 정의
#### 1. 아키텍쳐, 세부 설계, 내부 구조, 테스트 대상의 코드에 대한 분석을 기반으로 한다.
#### 2. 블랙박스 기법과는 달리, 테스트 대상의 내부 구조와 처리에 집중한다.

### 특징
#### 1. 테스트 컨디션, 테스트 케이스, 테스트 데이터는 코드, 소프트웨어 아키텍처, 상세 설계 또는 소프트웨어 구조와 관련된 기타 정보를 포함한 테스트 베이시스로부터 도출한다.
#### 2. 커버리지는 선택한 구조 내에서 테스트한 항목과 테스트 베이시스에 적용된 기법을 기준으로 측정한다.



### `경험 기반 테스트 기법`
### 정의
#### 1. 개발자, 테스터, 사용자의 경험을 활용하여 테스트를 설계, 구현, 실행한다.
#### 2. 이 기법은 블랙박스 및 화이트박스 테스트 기법과 결합해서 사용하는 경우가 많다.

### 특징
#### 1. 테스트 컨디션, 테스트 케이스, 테스트 데이터는 테스터, 개발자, 사용자, 기타 이해관계자의 지식과 경험과 같은 테스트 베이시스로부터 도출한다.


</div>
</details>

<details>
<summary> 4.2 블랙박스 테스트 기법 </summary>
<div>

## 4.2 블랙박스 테스트 기법

---
### 4.2.1 동등 분할
#### 특정 파티션의 모든 변수는 동일한 방식으로 처리된다는 가정으로 파티션에 데이터를 분할한다.
#### 유효한 값과 비유효한 값 모두에 대해 동등 분할을 구성할 수 있다.
- 유효값: 컴포넌트나 시스템에 입력되는 값이다. 유효환 값을 포함하는 동등한 파티션을 "유효 동등 분할"이라 한다.
- 비유효값: 컴포넌트나 시스템이 거부하는 값이다. 유효하지 않은 값을 포함하는 동등한 파티션을 "비유효 동등 분할"이라고 한다.
- 분할은 입력값, 출력값, 내부값, 시간관련값, 인터페이스 매개변수를 포함하여 테스트 대상과 관련된 모든 데이터 요소에 대해 식별할 수 있다.
- 필요한 경우 모든 파티션은 하위 파티션으로 나눌 수 있다.
- 모든 값은 동등 분할에 포함되어야 하며, 하나의 값은 하나의 동등 분할에만 속해야 한다.
- 비유효 동등 분할을 테스트 케이스로 만들 때는 장애가 마스크 즉, 가려지는 것을 방지하기 위해 개별적으로 테스트해야 하며, 다른 비유효 동등 분할과 조립하지 않아야 한다. 동시에 여러 장애가 발생할 때, 겉으로 드러나는 하나의 장애 때문에 나머지가 인식되지 않아 장애가 가려지는 경우가 발생한다.

#### 동등 분할 기법으로 100% 커버리지를 달성하기 위해서는 실별한 모든 분할의 각 분할에서 최소 한 개의 값을 사용해 테스트 케이스를 작성해야 한다.
#### 동등 분할 커버리지는 일반적으로 백분율로 표기하며, 최소한 한 개의 값으로 테스트한 동등 분할 수를 식별한 모든 동등 분할의 수로 나눠서 계산한다.
#### 동등 분할은 모든 테스트 레벨에서 적용할 수 있다.

---
### 4.2.2 경계값 분석
#### 동등 분할의 확장 형태이지만 각 파티션이 순서화되어 있고, 숫자 또는 연속 데이터로 구성된 경우에만 적용할 수 있다.
#### 분할의 최소값과 최대값은 해당 분할의 경계값이 된다.

#### 동등 분할의 경계에서 동작이 잘못될 확률이 동등 분할 중간의 값에서 잘못될 확률에 비해 높다. 명시된 경계값과 구현한 경계값 모두 의도했던 값보다 높거나 낮게 설정되거나, 모두 생략하거나 의도하지 않았던 경계값이 추가되었을 수 있다는 사실을 기억하는 것이 중요하다.
#### 경계값 분석과 테스팅을 통해 소프트웨어가 경계값이 원래 속한 분할의 동작이 아닌 다른 분할의 동작을 수행하는 것과 같은 종류의 결함 대부분을 식별할 수 있다.

#### 경계값 분석은 모든 테스트 레벨에 적용할 수 있으며, 일반적으로 숫자의 범위와 연관된 요구사항을 테스트하는 데 사용된다.

---
### 4.2.3 결정 테이블 테스팅
#### 시스템이 구현해야 하는 복잡한 비즈니스 규칙을 기록하기에 좋은 방법이다.
#### 결정 테이블을 작성할 때 테스터는 시스템의 조건과 예상 동작을 식별한다. (주로 입력과 출력)

#### 행(Row): 시스템의 조건과 예상 동작
#### 열(Column): 하나의 결정 규칙으로 특정 조건의 고유한 조합과 연관된 기대 결과

### 결정 테이블의 일반적인 표기법
#### 조건
- Y, 조건이 참이라는 것을 의미 (T, 1로 표기할 수 있음)
- N, 조건이 거짓이라는 것을 의미 (F, 0로 표기할 수 있음) 
- '-', 조건의 값이 중요하지 않다는 것을 의미 (N/A로 표기할 수 있음)

#### 기대 결과
- X, 행동이 일어난다는 것을 의미 (Y, T, 1로 표기할 수 있음)
- 공백(blank), 행동이 일어나지 않음을 의미 (-, N, F, 0로 표기할 수 있음)

#### 일반적인 최소 커버리지 기준은 테이블의 결정 규칙당 최소 한 개의 테스트 케이스를 작성하는 것이다.
#### 커버리지는 일반적으로 백분율로 표기하며, 최소 한 개의 테스트 케이스로 테스트한 결정 규칙의 수를 식별한 모든 결정 규칙의 수로 나눠서 계산한다.

### 결정 테이블 테스팅의 장점
#### 1. 중요한 모든 조건 조합을 식별하는데 도움이 된다.
#### 2. 요구사항의 누락된 부분을 찾는데에 도움이 된다.

---
### 4.2.4 상태 전이 테스팅
#### 상태 전이 다이어그램은 소프트웨어의 가능한 상태뿐만 아니라 소프트웨어가 상태 간에 어떻게 진입하고 빠져나오는지에 대한 전이 방법을 보여준다.
#### 전이는 이벤트에 의해 시작되며, 하나의 이벤트에 의해 동일한 상태로부터 두 개 이상의 다른 전이가 발생할 수 있다. 

#### 상태 전이 테이블은 상태 간의 모든 유효 전이와 잠재적인 비유효 전이뿐만 아니라, 유효 전이와 관련된 이벤트, 결과 조치를 보여준다.
#### 상태 전이 다이어그램은 일반적으로 유효한 전이만 보여주며, 비유효 전이는 표시하지 않는다.

#### 테스트는 상태의 일반적인 순서를 커버하거나, 모든 상태를 실행하거나 모든 상태 전이를 실행하거나 특정 상태 전이 순서를 실행하거나 또는 불가능한 상태 전이를 테스트하도록 설계할 수 있다.
#### 이 기법은 구체적인 상태를 포함한 비즈니스 시나리오를 모델링하거나 화면 탐색을 테스팅하는데 적합하다 (이는 코드 몇 줄 또는 전체 비즈니스 프로세스를 나타낼 수도 있다.)


---
### 4.2.5 유스케이스 테스팅
#### 유스케이스는 액터(사용자, 외부 하드웨어, 기타 컴포넌트)와 대상(컴포넌트나 시스템) 간의 관계이다.
#### 유스케이스를 상호작용과 활동으로 설명하기도 하고, 적절한 경우 사전조건, 사후조건 및 자연어로 설명할 수도 있다. (상호작용은 워크플로우, 활동 다이어그램, 비즈니스 프로세스 모델로 시각화하 수 있다.)

#### 유스케이스에는 예외 동작 및 오류 처리를 포함한 기본 동작의 가능한 변형이 포함된다. 테스트는 정의한 동작을 실행하도록 설계된다.
#### 커버리지는 일반적으로 숫자로 표기하며, 테스트한 유스케이스 동작 수를 모든 유스케이스 동작 수로 나눠서 계산한다.

</div>
</details>

<details>
<summary> 4.3 화이트박스 테스트 기법 </summary>
<div>

## 4.3 화이트박스 테스트 기법
#### 테스트 대상의 내부 구조를 기반으로 한다.
#### 모든 테스트 레벨에서 적용할 수 있지만, 이 절에서 언급하고 있는 두 가지 코드 관련 기법은 단위 테스트 레벨에서 가장 일반적으로 사용된다.

---
### 4.3.1 구문 테스팅과 커버리지
#### 코드의 잠재적으로 실행 가능한 구문을 실항하며, 커버리지는 일반적으로 백분율로 표기하며, 테스트를 실행한 구문의 수를 테스트 대상의 모든 실행 가능한 구문의 수로 나누어 계산한다.

---
### 4.3.2 결정 테스팅과 커버리지
#### 코드에 존재하는 결정문을 실행하고 결정문의 결과에 따라 실행되는 코드를 테스트한다.
#### 이를 달성하기 위해 테스트 케이스는 결정문에서 시작되는 제어 흐름을 따라 실행된다.
#### 커버리지는 일반적으로 백분율로 표기하며, 테스트로 실행된 결정문 결과의 수를 테스트 대상의 가능한 모든 결정문 결과의 수로 나눠서 계산한다.

---
### 4.3.3 구문 및 결정 테스팅의 가치
#### 구문 커버리지는 다른 테스트에 의해 실행되지 않은 코드의 결함을 찾는 데 도움이 된다.
#### 결정 커버리지는 다른 테스트가 참과 거짓 결과 모두를 테스트하지 않은 코드의 결함을 찾는 데 도움이 된다.
#### 100% 결정 커버리지는 100%구문 커버리지를 보장하지만, 반대의 경우는 성립되지 않는다.

</div>
</details>

<details>
<summary> 4.4 경험 기반 테스트 기법 </summary>
<div>

## 4.4 경험 기반 테스트 기법
#### 경험 기반 테스트 기법을 적용할 경우, 테스트 케이스는 테스터의 기술 역량과 직관 그리고 유사한 애플리케이션과 기술에 대한 경험을 기반으로 도출한다.
#### 체계적인 다른 기법으로는 쉽게 찾아내기 어려운 테스트를 식별하는데 도움이 된다.
#### 커버리지를 평가하기 어려울 수 있으며 측정이 불가능할 수 있다.

---
### 4.4.1 오류 추정
#### 오류, 결함 및 장애 발생 예측하는데 적용되는 기술
- 애플리케이션의 과거 동작
- 발생하기 쉬운 오류의 유형
- 다른 애플리케이션에서 발생한 장애

---
### 4.4.2 탐색적 테스팅
#### 비공식 테스트를 테스트 실행 중에 동적으로 설계, 실행, 기록하고 평가한다.
#### 테스트 결과는 컴포넌트나 시스템에 대해 더 많이 학습하고 테스트가 필요한 영역에 대한 테스트를 작성하는 데 활용된다.
#### 때때로, 세션 기반 테스팅을 사용하여 활동을 구성한다. 세션 기반 테스팅에서는 탐색적 테스팅을 정해진 시한동안 수행하며, 테스터는 테스트 목적이 포함된 테스트 차터를 활용해 테스팅 방향을 설정한다.

#### 탐색적 테스팅은 명세가 충분하지 않거나 적은 경우 또는 테스팅에 상당한 시간적 압박이 있을 때 가장 유용하다. 또한 공식적인 테스팅 기법을 보완하는 데에 유용하다.
#### 반응적 테스트 전략과 밀접하게 관련되어 있다. 탐색적 테스팅은 다른 블랙박스, 화이트 박스, 경험 기반 기법과 통합하여 사용할 수도 있다.

---
### 4.4.3 체크리스트 기반 테스팅
#### 체크리스트 기반 테스팅에서는 체크리스트에 기록된 테스트 컨디션을 커버하기 위해 테스터가 테스트를 설계, 구현, 실행한다. 테스터는 분석의 일환으로 새로운 체크리스트를 작성하거나 기존 체크리스트를 확장할 수 있지만, 기존 체크리스트를 수정하지 않고 그대로 사용하는 경우도 있다. 체크리스트는 경험, 사용자에게 무엇이 중요한지에 대한 지식 또는 소프트웨어가 실패하는 이유와 방법에 대한 이해를 기반으로 작성할 수 있다.
#### 체크리스트는 기능 및 비기능 테스팅을 포함한 다양한 테스트 유형을 지원하기 위해 작성할 수 있다. 구체적인 테스트 케이스가 없는 경우, 체크리스트 기반 테스팅은 대략적인 지침과 일관성을 제공할 수 있다. 이런 체크리스트는 상위 수준으로 작성되기 때문에 실제 테스팅에서 어느 정도의 가변성이 있기 마련이며, 따라서  커버리지는 늘어날 수 있지만 재현 가능성은 줄어들 수 있다.


</div>
</details>


</div>
</details>

---
<details>
<summary>
<font size="4em" color="blue">
5장 테스트 관리
</font>
</summary>
<div>

<details>
<summary> 5.1 테스트 조직</summary>
<div>

## 5.1 테스트 조직

### 5.1.1 독립적인 테스팅
#### 테스팅 작업은 특정 테스팅 역할을 부여 받은 사람이나 다른 역할을 하는 사람도 수행할 수 있다.
#### 저자와 테스터가 가지는 인지편향의 차이 때문에 일정 수준의 독립성은 테스터가 결함을 더 효과적으로 찾게 해주지만, 독립성이 친숙함을 대체할 수 없으며 개발자도 자신이 작성한 코드에서 많은 결함을 효율적으로 찾아낼 수 있다.

#### 독립성 수준
- 독립적인 테스터 없음: 유일하게 개발자가 자신의 코드를 직접 테스트하는 형태
- 개발팀이나 프로젝트팀에 속한 독립적인 개발자나 테스터: 개발자가 동료의 제품을 테스트하는 형태도 포함.
- 조직 내 독립적 테스트 팀이나 그룹이 프로젝트 관리자나 상위 관리자에게 직접 보고
- 비즈니스 조직 또는 사용자 커뮤니티 소속이거나 사용성, 보안성, 성능, 준수성, 이식성 등 특정 테스트 분야를 전문으로 하는 독립적인 테스터
- 현장 또는 현장 외에서 일하는 조직 외부의 독립적인 테스터

#### 테스트 독립성의 잠재적 이점
- 독립적인 테스터는 그들이 가지고 있는 다양한 배경, 기술적 관점, 성향이 달라 개발자와는 다른 유형의 장애를 찾아낼 수 있다.
- 독립적인 테스터는 이해관계자가 시스템 명세를 정의하고 구현하면서 만든 가정에 대해 확인하고 이의를 제기하고 틀렸음을 입증할 수 있다.
- 벤더의 독립 테스터는 테스트할 시스템을 고용한 회사의 압박 없이 똑바로 그리고 객관적으로 보고할 수 있다.

#### 테스트 독립성의 잠재적 단점
- 개발팀과의 고립으로 협업이 어려울 수 있고, 개발팀에게 피드백 전달이 늦어지고, 개발팀과 적대적인 관계가 형성될 수 있다.
- 개발자가 품질에 대한 책임감을 잃을 수 있다.
- 독립적인 테스터가 병목 현상의 장본인으로 비쳐질 수 있다.
- 독립적인 테스트는 중요한 정보를 전달받지 못할 수 있다.

---
### 5.1.2 테스트 관리자 및 테스터의 역할
#### 두 역할담당자의 활동과 업무는 프로젝트와 제품의 정황, 담당자의 역량, 조직 상황에 따라 달라진다.

### 테스트 관리자의 역할과 업무
- 조직의 테스트 정책과 테스트 전략을 개발하고 리뷰
- 정황을 고려한 테스트 활동과 테스트 목적과 리스크 이해를 바탕으로 테스트 활동을 계획
- 테스트 계획서 작성 및 업데이트
- 프로젝트 관리자, 제품 책임자, 기타 관계자와 테스트 계획 관리 협의
- 통합 계획 등과 같은 다른 프로젝트 활동과 테스팅 관점 공유
- 테스트 분석, 설계, 구현, 실행 활동을 개시하고, 테스트 진행과 결과를 모니터링하며 종료 조건의 상태를 점검하고 테스트 완료 활동을 촉진
- 수집한 정보를 바탕으로 테스트 진행 상황 보고서와 테스트 요약 보고서 작성과 배포
- 테스트 결과와 진행 상황에 따라 계획을 조정하고 테스트 제어에 필요한 모든 조치를 취함
- 결함 관리 시스템과 테스트웨어에 적합한 형상 관리 체제 구축 지원
- 테스트 진척 상황 측정과 테스팅 및 제품 품질 평가를 위한 적절한 메트릭 도입
- 테스트 프로세스 지원용 도구 선택과 구현 지원
- 테스트 환경 구축에 관한 결정
- 조직에 테스터, 테스트팀 테스트 활동을 홍보하고 지지를 요청
- 테스터의 역량과 경력 개발

#### 테스트 관리자의 역할은 소프트웨어 개발 수명주기의 영향을 받는다.
#### 예를 들어, 애자일 개발에서 애자일팀은 위에서 언급한 일부 역할을 수행하는데, 팀 내에서 매일 이루어지는 테스팅 관련 작업이 그러하며 팀에 속한 테스터가 수행하는 경우가 많다.
#### 여러 팀에 걸쳐 있거나 전체 조직 또는 인력 관리와 관련한 일부 직무는 개발팀에 속하지 않은 테스트 관리자가 수행하기도하는데, 이런 테스트 관리자를 테스트 코치라고 한다.

### 테스터의 역할과 업무
- 테스트 계획을 리뷰하고 계획 작성에 참여
- 요구사항, 사용자 스토리와 인수 조건, 명세, 모델의 테스트 용이성을 분석, 리뷰, 평가
- 테스트 컨디션을 식별 및 기록하고, 테스트 케이스, 테스트 컨디션, 테스트 베이시스 간의 추적성 설정
- 테스트 환경을 설계, 구축, 검증하고 필요한 경우 시스템 관리자, 네트워크 관리자와 협의
- 테스트 케이스와 테스트 프로시저를 설계 및 구현
- 테스트 데이터를 준비하고 획득
- 상세 테스트 실행 일정 수립
- 테스트를 실행하고 결과를 평가해, 기대 결과와 차이 기록
- 테스트 프로세스에 적합한 도구 사용
- 필요한 경우 테스트 자동화
- 수행 효율성, 신뢰성, 사용성, 보안성, 호환성, 이식성과 같은 비기능 품질 특성 평가
- 테스트 산출물 리뷰

#### 테스트 분석, 테스트 설계, 특정 테스트 유형, 테스트 자동화에 관련해 일하는 사람은 각자의 역할에 전문가일 수 있다. 제품과 프로젝트의 리스크나 선택한 소프트웨어 개발 수명주기 모델에 따라 테스트 레벨별로 테스터의 역할이 다를 수 있다.


</div>
</details>


<details>
<summary> 5.2 테스트 계획과 추정 </summary>
<div>

## 5.2 테스트 계획과 추정

### 5.2.1 테스트 계획의 목적과 내용
#### 계획에 영향을 주는 요소로는 조직의 테스트 정책과 테스트 전략, 사용하는 개발 수명주기 및 방법, 테스트 범위, 목적, 리스크, 제약, 심각도, 테스트 용이성, 자원 가용성 등이 있다.
#### 계획은 마스터 테스트 계획의 일부로 작성하거나 시스템 테스팅, 인수 테스팅과 같은 테스트 레벨별 또는 사용성 테스팅, 성능 테스팅과 같은 테스트 유형별 테스트 계획으로 나눠서 작성할 수도 있다.

#### 테스트 계획 활동 내용
- 테스팅의 범위 정의, 목적, 리스크 결정
- 전반적인 테스팅 접근법 정의
- 테스트 활동의 소프트웨어 수명주기 활동에 통합하고 조정
- 테스트 대상 다양한 테스트 활동에 필요한 인력과 기타 자원, 테스트 활동 수행 방법 결정
- 테스트 분석, 설계, 구현, 실행, 평가 활동의 일정 조정, 일정은 특정 날짜나 반복주기 단위로 편성할 수 있다.
- 테스트 모니터링과 제어에 사용할 메트릭 선정
- 테스트 활동 예산 결정
- 테스트 문서의 구조와 상세화 정도 정의

---
### 5.2.2 테스트 전략과 접근법
#### 테스트 전략 유형
#### 분석적
- 특정 요소에 대한 분석을 기반으로 한 테스트 전략
- 리스크 수준에 따라 테스트를 설계하고 우선순위를 결정하는 리스크 기반 테스팅이 분석적 접근법의 예시이다.

#### 모델 기반
- 요구되는 제품의 특정 측면에 대한 모델을 기반으로 만들어진다.
- 특정 측면에는 기능, 비즈니스 프로세스, 내부 구조, 비기능 특성 등이 존재한다.
- 모델에는 비즈니스 프로세스 모델, 상태 모델, 신뢰성 성장 모델 등이 있다.

#### 방법론적
- 사전에 정의한 테스트 셋이나 테스트 컨디션을 체계적으로 사용하는 데 의존한다.

#### 프로세스 수준 (또는 표준 수준)
- 외부 규정이나 표준을 기반으로 테스트를 분석, 설계 구현한다.

#### 전문가 조언
- 주로 이해관계자, 비즈니스 도메인 전문가, 기술 전문가 등의 조언, 지시, 지도를 바탕으로 이루어 진다. (외부 팀일 수 있다.)

#### 리그레션-기피
- 기존 테스트웨어의 재사용, 리그리션 테스트 자동화 확대, 테스트 스위트 표준화가 포함된다.

#### 반응적
- 테스트 대상 컴포넌트나 시스템에 따라 대응하고 테스트 실행 중 발생하는 이벤트에 따라 반응적으로 수행하는 테스트 접근법이다.
- 이전 테스트 결과에서 얻은 지식을 바탕으로 테스트를 설계하고 구현하며 즉각 테스트를 수행할 수 있다.
- 탐색적 테스팅이 반응적 전략에서 일반적으로 사용하는 기법이다.

#### 앞서 나열한 테스트 전략의 일부를 조합해 적절한 테스트 전략을 만든다.

#### 테스트 전략은 테스트 프로세스를 종합해 개괄적으로 설명하는 반면, 테스트 접근법은 특정 프로젝트나 릴리스용으로 테스트 전략을 조정한 것이다.

#### 테스트 접근법
- 테스트 기법, 테스트 레벨, 테스트 유형을 선택하는 출발점
- 시작 조건과 종료 조건을 정의하는 출발점
- 프로젝트의 복잡도와 목표, 개발하는 제품 유형, 제품 리스크 평가에 관한 결정을 기반으로 테스트 전략을 조정
- 정황을 기반으로 선택하고 리스크, 안전 사항, 사용 가능한 자원과 역량, 기술, 시스템 특성, 테스트 목적과 규정 같은 요소를 고려한다.

---
### 5.2.3 시작 조건과 종료 조건
#### 시작 조건
- 충족하지 못하면 해당 활동을 수행하기 어렵고 더 많은 시간을 필요로 한다.
- 더 많은 비용이 들고 리스크에 노출될 가능성이 높아진다

#### 일반적인 시작 조건
- 테스트 가능한 요구사항, 사용자 스토리나 모델의 가용 여부
- 이전 테스트 레벨의 종료 조건을 충족한 테스트 항목의 가용 여부
- 테스트 환경 가용 여부
- 필요한 테스트 도구 가용 여부
- 테스트 데이터와 기타 필요한 자원의 가용 여부

#### 종료 조건
- 특정 테스트 레벨이나 테스트 세트가 끝났음을 선언하기 위해 만족해야 할 조건을 정의한다.
- 각 테스트 레벨과 테스트 유형의 시작과 종료를 정의 하고 이는 테스트 목적에 따라 달라진다.

#### 일반적인 종료 조건
- 계획한 테스트 실행 완료
- 정의한 커버리지 수준의 도달
- 해결하지 못한 결함 수가 합의된 수보다 적음
- 추정 잔존 결함의 수가 충분히 적음
- 신뢰성, 수행 효율성, 사용성, 보안성, 기타 관련된 품질 특성의 수준이 원하는 수준에 도달

---
### 5.2.4 테스트 실행 일정
#### 테스트 케이스와 테스트 프로시저를 작성하고 테스트 프로시저와 테스트 케이스를 조합해 테스트 스위트를 생성한 후 테스트 스위트의 순서를 정해 실행 일정을 만들 수 있다.
#### 테스트 실행 일정을 만들 때는 우선순위, 종속관계, 확인 테스트, 리그레션 테스트, 가장 효율적인 테스트 실행 순서 등을 고려해야 한다.

#### 이상적인 테스트 케이스 실행 순서
- 가장 우선순위가 높은 테스트 케이스를 먼저 실행하는 것이다.
- 실제로 테스트 케이스 간에 종속 관계가 있거나 테스팅 대상의 기능 자체가 종속 관계라면 우선순위에 따라 실행하지 못할 수 있다.
- 우선순위가 높은 테스트 케이스가 우선순위가 낮은 테스트 케이스에 종속되어 있다면 낮은 우선순위를 가진 테스트 케이스를 먼저 실행해야 한다.

#### 테스트 케이스가 서로 종속 관계를 가지고 있다면 각자의 우선순위와 관계없이 필요에 따라 배치해야 한다.
#### 확인 및 리그레션 테스트 역시 수정에 대한 피드백의 중요도에 따라 우선순위를 정해야 하고 이 경우에 종속 관계를 적용할 수 있다.

---
### 5.2.5 테스트 노력에 영향을 미치는 요소
#### 테스트 노력 추정
- 테스트 관련 작업에 필요한 노력의 양을 예측하는 활동이다.
- 특정 프로젝트, 릴리스, 반복주기에서 테스팅의 목적을 충족하는 데 필요하다.

#### 테스트 노력에 영향을 주는 요소
- 제품의 특성
- 개발 프로세스 특성
- 관련 인물의 특성
- 테스트 결과 등

### 제품 특성
- 제품과 관련된 리스크
- 테스트 베이시스의 품질
- 제품의 크기
- 제품 도메인의 복잡도
- 품질 특성 요구사항
- 요구되는 테스트 문서의 상세화 정도
- 법적, 규제 준수 요구사항

### 개발 프로세스 특성
- 조직의 안정성과 성숙도
- 사용하는 개발 모델
- 테스트 접근법
- 사용되는 도구
- 테스트 프로세스
- 시간적 압박

### 인력 특성
- 관련된 인원의 역량과 경험, 특히 유사한 프로젝트나 제품 관련 도메인 지식
- 팀 응집력과 리더십

### 테스트 결과
- 발견한 결함 수와 심각도
- 필요한 재작업 규모

---
### 5.2.6 테스트 추정 기법
#### 메트릭 기반 기법
- 기존 유사한 프로젝트에서 얻은 메트릭에 기반하거나 보편적인 값을 바탕으로 테스트 노력 예측
- 전문가 기반 기법: 테스팅 작업의 책임자나 전문가의 경험을 기반으로 테스트 노력 예측

#### 순차적 개발 프로젝트에서의 메트릭 기반 접근법의 예시
- 결함 제거 모델
- 결함의 양과 결함을 제거하는데 드는 시간을 파악하고 보고해서 차후 비슷한 성격의 프로젝트를 추정하는 기준으로 사용

#### 전문가 기반 접근법의 예시
- 와이드밴드 델파이 추정 기법
- 전문가 집단의 경험을 기반으로 추정치를 제공한다.

</div>
</details>


<details>
<summary> 5.3 테스트 모니터링과 제어 </summary>
<div>

## 5.3 테스트 모니터링과 제어
#### 테스트 모니터링의 목적
- 정보 수집 및 테스트 활동에 대한 피드백과 가시성

### 테스트 제어
#### 정의: 수집하고 보고된 정보와 메트릭의 결과로 취해진 수정 조치나 가이드
#### 수정 조치(활동): 어떤 테스트 활동을 커버하거나 소프트웨어 수명주기 활동에 영향을 미칠 수 있다.

#### 테스트 제어 활동의 예시
- 식별한 리스크 발생 시 테스트 우선순위의 변경
- 테스트 환경이나 기타 자원의 가용 여부에 따라 테스트 일정 변경
- 재작업으로 인해 테스트 항목이 시작 조건이나 종료 조건 만족하는지 재평가

---
### 5.3.1 테스팅에 사용하는 메트릭
#### 테스팅 활동 중이나 종료 시점에 아래와 같은 사항을 평가하기 위해 메트릭을 수집한다.
- 계획된 일정과 예산 대비 진행 상황
- 테스트 대상의 현재 품질
- 테스트 접근법의 타당성
- 목적 대비 테스트 활동의 효과

### 일반적인 테스트 메트릭
- 계획 대비 테스트 케이스 준비 작업 완료율
- 계획 대비 테스트 환경 준비 작업 완료율
- 테스트 케이스 실행률
- 결함 정보
- 요구사항 커버리지, 사용자 스토리 커버리지, 인수 기준 커버리지, 리스크 커버리지, 코드 커버리지
- 작업 완료, 자원 할당과 사용, 노력
- 결함을 발견하면 얻는 이익 대비 비용이나 테스트를 계속 실행해 얻게 되는 이익 대비 비용 등을 포함하는 테스팅 비용

---
### 5.3.2 테스트 보고의 목적, 내용, 독자
#### 테스트 진행 상황 보고서
- 테스트 활동 중 작성하는 테스트 보고서

#### 테스트 요약 보고서
- 테스트 활동 종료 시점에 작성하는 테스트 보고서

#### 공통으로 들어가는 보고 외에 일반적인 테스트 진행 상황 보고서에 들어가는 정보
- 테스트 계획 대비 테스트 활동과 진행 상황
- 진행을 방해하는 요소
- 다음 보고 기간에 진행하기로 계획한 테스팅
- 테스트 대상의 품질

#### 일반적인 테스트 요약 보고서 내용
- 테스팅 수행 내용 요약
- 테스트 기간 도중에 발생한 상황 정보
- 계획 대비 편차
- 종료 조건 및 완료의 정의에 대한 테스팅 현황과 제품 품질
- 진행을 방해했거나 계속해서 방해하고 있는 요소
- 메트릭(결함, 테스트 케이스, 테스트 커버리지, 활동 진행 상황, 소비한 자원)
- 잔존 리스크
- 재사용 가능한 테스트 작업 산출물

#### 테스트 보고서 내용은 프로젝트, 조직 요구사항, 소프트웨어 개발 수명주기에 따라 달라진다.
#### 테스트 보고서는 프로젝트 정황뿐 아니라 보고의 대상자에 따라서도 조정해야 한다.
#### 기술적인 배경이 있거나 테스트팀을 대상으로 하는 보고서의 형식이나 내용은 경영층을 대상으로 하는 요약 보고서와 달라야 한다.
#### 전자에서는 결함 유형과 추세에 대한 상세한 정보가 중요하고, 후자에서는 상위 수준으로 작성된 보고서가 더 적절할 수 있다.
</div>
</details>


<details>
<summary> 5.4 형상 관리 </summary>
<div>

## 5.4 형상 관리
#### 목적
- 프로젝트와 제품 수명주기 동안 컴포넌트나 시스템, 테스트웨어와 이들 서로간의 관계 통합을 수립하고 유지하는 데 있다.

#### 확인할 내용
- 모든 테스트 항목에 고유 식별번호를 부여하고, 버전을 관리하고, 변경 이력을 기록한다.
- 항상 관리에서 테스트 항목은 서로 연관돼 있다.
- 모든 테스트웨어 항목에 고유 식별번호를 부여하고, 버전을 관리하고, 변경사항을 추적하고, 서로 연결해 테스트 항목 버전과도 연결되도록해서 테스트 프로세스 전반에 걸쳐 추적성을 유지할 수 있게 한다.
- 식별한 모든 문서와 소프트웨어 아이템은 테스트 문서 내에서 명확하게 상호 참조되도록 한다.

#### 테스트 계획을 수립하면서 형상관리 절차와 인프라(도구)를 식별하고 구현해야 한다.

</div>
</details>


<details>
<summary> 5.5 리스크와 테스팅 </summary>
<div>

## 5.5 리스크와 테스팅
### 5.5.1 리스크의 정의
#### 미래에 부정적 결과를 가져오는 이벤트의 발생 가능성
#### 리스크 수준은 이벤트 발생 가능성과 이벤트로 인한 영향도(피해)로 결정한다.

---
### 5.5.2 제품 및 프로젝트 리스크
#### 제품 리스크
- 작업 산출물이 사용자나 이해관계자의 합당한 니즈를 충족하지 못할 가능성이다.
- 제품의 특정 품질 특성과 연관되는 경우 품질리스크라고도 한다.

#### 품질 리스크
- 소프트웨어가 명세에서 의도한 기능을 수행하지 못함
- 소프트웨어 사용자, 고객이나 이해관계자가 요구하는 기능을 수행하지 못함
- 시스템 아키텍처가 일부 비기능 요구사항을 충분히 지원하지 못함
- 특정 계산식이 특정 상황에서 올바르게 수행되지 못함
- 루프(반복) 제어 구조 코딩이 잘못됨
- 고성능 거래 처리 시스템의 응답 시간이 적절하지 않음
- 사용자 경험 피드백이 제품 기대치에 미치지 못함

#### 프로젝트 리스크는 프로젝트 이슈, 조직 이슈, 정치적 이슈, 기술적 이슈, 공급자 이슈 등으로 다양하며, 개별 활동과 테스트 활동 양쪽 모두에 영향을 미칠 수 있다.
#### 프로젝트 관리자가 모든 프로젝트 리스크에 대해 책임을 지는 것이 일반적이지만, 테스트와 관련된 프로젝트 리스크는 테스트 관리자가 책임을 지는 경우도 있다.

---
### 5.5.3 리스크 기반 테스팅과 제품 품질
#### 테스팅은 부정적인 이벤트의 발생 가능성을 줄이거나 부정적인 이벤트의 영향을 줄이기 위해 사용한다.
#### 식별한 리스크뿐 아니라 잔존 리스크에 대한 것을 완화하는 것도 중요하다.

### 리스크 기반 접근법
#### 특징
- 제품 리스크 수준을 조기에 낮추는 데 기여한다.
- 제품 리스크 식별과 리스크 발생 가능성과 영향을 평가하는 제품 리스크 분석을 포함한다.
- 제품 리스크 정보로 얻은 결과는 **테스트 계획, 명세, 테스트 케이스 준비와 실행, 테스트 모니터링**에 사용한다.

#### 제품 리스크 분석 결과가 사용되는 범위
- 사용할 테스트 기법 결정
- 수행할 테스트 레벨과 유형 확정
- 테스트 수행 범위 결정
- 가능한 조기에 심각한 결함을 발견하기 위해 테스트 우선순위 결정
- 기존 테스팅 활동 외 리스크 완화를 위한 다른 활동의 식별

### 리스크 기반 테스팅
#### 특징
- 프로젝트 이해관계자의 집단 지식과 통찰력을 기반으로 제품 리스크를 분석한다. 

#### 제품 장애 발생 가능성을 최소화하기 위한 리스크 관리 활동 절차
- 잘못될 수 있는 것을 분석
- 처리해야 할 중요한 리스크가 무엇인지 판단
- 해당 리스크를 완화하기 위한 행동 구현
- 리스크의 실제 발생을 대비한 대책 수립

</div>
</details>


<details>
<summary> 5.6 결함 관리 </summary>
<div>

## 5.6 결함 관리
#### 결함을 기록하는 방법은 테스트 대상 컴포넌트나 시스템의 정황, 테스트 레벨, 소프트웨어 개발 수명주기 모델에 따라 달라진다.
#### 찾아낸 모든 결함은 조사하고, 발견해서 결함 분류까지 추적해야 한다.
#### 모든 결함을 해결까지 관리하기 위해 조직은 결함 관리 프로세스를 수립해야 한다.
#### 아키텍처, 설계자, 개발자, 테스터, 제품 책임자 등 결함 관리에 참여하는 모든 사람이 프로세스에 동의해야하며, 일부 조직에서는 결함 로깅과 추적이 매우 비공식적일 수 있다.

### 결함 보고서의 목적
- 발생한 모든 부정적인 이벤트 정보를 개발자와 기타 관계자에게 제공해 구체적인 영향을 식별하고, 재현 테스트로 문제를 격리하고, 잠재 결함을 수정하고, 필요에 따라서는 문제를 해결할 다른 방법으로 찾을 수 있도록 한다.
- 테스트 관리자에게 작업 산출물의 품질과 테스팅 영향을 추적할 방법을 제공한다.
- 개발과 테스트 프로세스 개선에 대한 아이디어를 제공한다.

### 동적 테스팅에서 작성하는 결함 보고서 내용
- 식별 번호
- 제목, 보고하는 결함에 대한 짧은 요약
- 결함 보고 날짜, 보고 주체 조직 및 작성자
- 테스트 항목 식별자와 환경
- 결함을 발견한 개발 수명주기 단계
- 로그, 데이터베이스 덤프, 스크린샷, 녹화 기록 등의 결함 재현과 해결을 위한 설명
- 기대 및 실제 결과
- 이해관계자의 관점에서의 결함 영향도의 범위와 정도
- 수정 우선순위
- 결함 보고서의 상태
- 결론, 의견, 승인 여부
- 글로벌 이슈(ex, 결함 수정의 결과로 영향을 받는 다른 영역)
- 변경 이력 (ex, 프로젝트 팀원이 결함을 격리하고 복구하고, 수정 여부를 확인하는 데 취한 조취 순서)
- 참조 (문제를 발견하게 해 준 테스트 케이스 포함)

</div>
</details>

</div>
</details>

---
<details>
<summary>
<font size="4em" color="purple">
6장 테스트 지원 도구
</font>
</summary>
<div>

<details>
<summary> 6.1 테스트 도구 고려 사항</summary>
<div>

## 6.1 테스트 도구 고려 사항
#### 테스트 도구의 종류
- 테스팅에 직접 사용하는 도구(ex, 테스트 실행 도구, 테스트 데이터 준비 도구)
- 요구사항, 테스트 케이스, 테스트 프로세스, 자동 테스트 스크립트, 테스트 결과, 테스트 데이터, 결함을 관리하고, 테스트 실행 보고와 모니터링을 지원하는 도구
- 분석과 평가에 사용되는 도구
- 테스팅을 지원하는 모든 도구 (이런 의미에서 스프레드시트도 테스트 도구임)

---
### 6.1.1 테스트 도구의 분류
#### 정황에 따라 다음과 같은 하나 이상의 목적이 존재한다.
- 반복적인 작업이나 수동으로 진행했을 때, 상당한 리소스를 필요로 하는 작업
- 테스트 프로세스 전판에 걸쳐 수동 테스트 활동을 지원해서 테스트 활동의 효율성을 높인다.
- 테스팅의 일관성과 결함 재현성 향상으로 테스트 활동의 품질을 향상시킨다.
- 수동으로 실행할 수 없는 활동을 자동화한다.
- 테스팅의 신뢰성을 향상한다.

#### 도구는 목적, 가격, 라이센스 모델, 사용된 기술에 따라 분류할 수 있다.
#### 특징
- 어떤 도구는 명확하게 하나의 테스트 활동만을 지원하고 어떤 도구는 하나 이상의 활동을 지원하기도 한다.
- 도구 자체가 테스트의 실제 결과에 영향을 준다는 의미에서 침입적 도구도 있다.
- 침입적 도구를 사용해 달라진 결과를 `탐사 효과`라 부른다.

#### `개발자 지원`으로 표기된 도구
- 컴포넌트 테스트나 컴포넌트 통합 테스트 중 개발자에게 더 적절한 도구

### 테스팅 및 테스트웨어 관리 지원 도구
- 테스트 관리 도구와 애플리케이션 수명주기 관리 도구 (ALM, application lifecycle management tool)
- 요구사항 관리 도구
- 결함 관리 도구
- 형상 관리 도구
- 지속적인 통합 도구 (개발자 지원)

### 정적 테스팅 지원 도구
- 정적 분석 도구 (개발자 지원)

### 테스트 설계 및 구현 지원 도구
#### 내용: 테스트 설계와 구현 단계에서 작업 산출물을 유지보수하는데 도움을 준다.
- 모델 기반 테스팅 도구
- 테스트 데이터 준비 도구

#### 테스트 설계와 구현을 지원하는 도구가 테스트 실행과 로깅을 지원하기도 하고 테스트 설계와 구현 도구가 테스트 실행과 로깅을 지원하는 다른 도구에 결과를 제공하기도 한다.

### 테스트 실행 및 로깅 지원 도구
- 테스트 실행 도구 (ex, 리그레션 테스트 수행)
- 커버리지 도구 (ex, 요구사항 커버리지, 코드 커버리지(개발자 지원))
- 테스트 하네스 (개발자 지원)

### 성능 측정과 동적 분석 지원 도구
#### 내용: 성능 측정 및 동적 분석 도구는 성능 및 부하 테스트 활동이 수동으로는 효과적으로 수행할 수 없기 때문에, 이를 지원하는데 필수적이다.
- 성능 테스팅 도구
- 동적 분석 도구 (개발자 지원)

### 특수 목적 테스팅 지원 도구
- 일반적인 테스트 프로세스를 지원하는 도구 외 비기능적 특징을 커버하기위한 특정적인 테스팅을 지원하는 도구

---
### 6.1.2 테스트 자동화의 효과와 리스크
### 잠재적 가치
- 반복적인 수동 업무의 감소로 시간 절약
- 월등한 일관성과 반복성 제공
- 보다 객관적인 평가 기준 제공
- 테스팅 관련 정보에 접근이 쉽다.

### 잠재적인 리스크
- 도구에 대한 비현실적인 기대
- 초기 도구 도입에 필요한 시간, 비용, 노력에 대한 과소평가
- 도구로 의미있고 지속적인 효과를 얻는 데 필요한 시간과 노력을 과소 평가
- 도구가 생성하는 테스트 작업 산출물을 유지하기 위한 노력의 과소평가
- 도구에 대한 지나친 의존
- 테스트 작업 산출물에 대한 버전의 관리 소홀
- 요구사항 관리 도구, 형상 관리 도구, 결함 관리 도구, 다수의 공급 업체에서 제공하는 도구 환경에서 주요 도구 간의 관계와 상호운용성 이슈를 관리하지 않음
- 도구 공급 업체의 폐업, 해당 도구의 판매 중단, 해당 도구가 다른 공급 업체에 매각될 수 있음
- 지원, 업그레이드, 결함 수정에 대한 공급 업체의 부적절한 대응
- 오픈소스 프로젝트는 연기되거나 중단될 수 있음
- 도구가 새로운 플랫폼이나 기술을 지원하지 않음
- 도구의 소유권이 명확하지 않음 (업데이트의 어려움)

---
### 6.1.3 테스트 실행 및 테스트 관리 도구 고려사항
### 테스트 관리 도구
#### 캡쳐 기반 테스트 접근법
- 테스터의 수동적인 조작을 녹화해 테스트를 캡쳐하는 것은 매력적으로 보일 수 있지만 이러한 접근 방법은 테스트 스크립트의 수가 많을 경우 적절하지 않다.
- 캡처한 스크립트마다 특정 데이터와 행위를 1차원적으로 표현하고 있기 때문에 미쳐 예상하지 못한 이벤트가 발생하면 취약할 수 있으며, 시스템의 사용자 인터페이스가 시간이 지남에 따라 바뀌게 되면 스크립트도 그에 맞게 계속해서 유지보수를 해 줄 필요가 있다.

#### 데이터 주도 테스트 접근법
- 테스트 입력값과 기대 결과값을 보통 스프레드시트에 저장하고 더 많은 공통 스크립트를 활용해 해당 테스트 데이터를 읽어 들여 동일한 테스트 스크립트를 매번 다른 데이터로 반복적으로 실행한다.

#### 키워드 주도 테스트 접근법
- 해야할 행동을 설명하는 키워드를 공통 스크립트가 처리해 키워드 스크립트를 호출한다. 키워드 스크립트는 연관된 테스트 데이터를 처리한다.

#### 위 3가지 접근법은 스크립트 언어 전문가가 필요하다.

### 모델 기반 테스팅 도구
- 일반적으로 시스템 설계자가 수행한다.
- 모델 기반 테스팅 도구(MBT)는 모델을 해석해 테스트 케이스 명세를 생성하고, 생성한 명세는 테스트 관리 도구에 저장하거나 테스트 실행 도구로 실행한다.

#### 테스트 관리 도구
- 스프레드시트와 연동해야 하는 경우가 많다.
  - 필요한 정보를 생성하기 위해
  - 요구사항 관리 도구에 저장된 요구사항과의 추적성을 지속적으로 유지하기 위해
  - 형상 관리 도구에 저장된 테스트 대상 버전 정보와 연결하기 위해

#### 통합 도구(ALM)를 사용할 때 특히 중요하며, 애플리케이션 수명주기 관리 도구에는 조직 내 다양한 그룹에서 사용하는 기타 모듈뿐 아니라 테스트 관리 도구 모듈도 들어있다.

</div>
</details>

<details>
<summary> 6.2 도구의 효과적인 사용</summary>
<div>

## 6.2 도구의 효과적인 사용
### 6.2.1 도구 선택의 주요 원칙
#### 고려 사항
- 조직의 강점, 약점 등 성숙도 수준 평가
- 도구의 지원으로 테스트 프로세스 개선 기회 식별
- 테스트 대상이 이용하는 기술을 이해해 테스트 대상과 호환 가능한 도구 선택
- 호환과 통합이 가능한 도구 확인을 위해 조직에서 이미 사용하고 있는 빌드와 지속적인 통합 도구 이해
- 명확한 요구사항과 개관적인 기준에 맞는 도구 평가
- 도구를 일정 기간 무료로 시험해 볼 수 있는지 여부
- 공급자 평가 또는 비 상업적 도구 지원 평가
- 조직이 요구하는 도구 사용 코칭과 멘토 요구사항 식별
- 도구를 직접 사용할 사람의 테스팅 역량을 고려한 훈련 수요 확인
- 다양한 라이센스 모델의 장단점 고려
- 필요 시 구체적인 비즈니스 사례에 근거해 비용 대비 효과 추정

#### 사전 검증 진행
- 사전 검증으로는  테스트 대상 소프트웨어와 현재 인프라 환경에서 도구가 효과적으로 동작하는지 확인하고 필요한 경우에는 효율적으로 도구를 사용하는 데 필요한 요구사항을 식별한다.

---
### 6.2.2 도구 도입을 위한 파일럿 프로젝트
#### 파일럿 프로젝트
- 도구 선택과 사전 검증이 성공적으로 끝난 다음 선택한 도구를 조직에 도입하는 시점

### 파일럿 프로젝트의 목적
- 깊이 있는 도구 지식의 습득 (장단점 모두 이해)
- 도구를 기존 프로세스와 프랙티스에 어떻게 적용할지 평가하고 무엇을 변경할지 결정
- 도구와 테스트 작업 산출물의 사용, 관리, 저장, 유지보수에 대한 기준 결정
- 목표한 가치를 적절하게 비용으로 달성할 수 있는지 평가
- 도구에서 수집하고 보고하기를 희망하는 메트릭을 이해하고 그런 메트릭을 도출하고 보고할 수 있도록 도구를 설정

---
### 6.2.3 도구 성공 요인
- 조직의 다른 부서에 도구 사용 전파를 점진적으로 진행
- 도구의 사용법에 맞게 프로세스를 수정하고 개선
- 도구 사용자에게 교육, 코칭, 멘토링 제공
- 도구사용에 필요한 지침을 정의
- 실제 도구 사용에서 얻은 사용법 정보의 수집 방법 구현
- 도구 사용 현황과 성과를 모니터링
- 특정 도구 사용자에게 지원 제공
- 모든 사용자로부터 사용 후 교훈 수집

#### 소프트웨어 개발 수명주기와 도구를 기술적으로, 유기적으로 통합하는게 중요하다.

</div>
</details>

</div>
</details>
